#!/bin/bash

if [ -z "$APTAMD" ]; then echo "APTAMD variable is not defined!" ; exit; fi
source $APTAMD/ENV/aptamd_env.sh
source $AMBERHOME/amber.sh

#
# This is the APTAMD script for carrying out MMPBSA, MMGBSA, MMPB , QMMMPBSA, QMMMGBSA  and QMMPB calculations
#
# The non-polar solvation in the PBSA/GBSA schemes is described with the Ecav and Edisp formulas implemented
# in AMBER. This approach should be more accurate than the gamma*Surf term,
#
# The MMPB and QMMMPB schemes include solute-solvent VDW interactions in the non-polar solvation.
#
# When QMMM is requested, the QM region is relaxed via energy minmimization.
# For QM=SCC-DFTB, SCF convergence is tested first by single-point calc.
#
# For QMMMPB calcs, PB is peformed using the Mulliken charges of the QM region 
# The link atom charges are evenly distributed among the real QM  atoms.
# to preserve charge integrity. This is done with a short Octave script.
# Similarly, a code by us, fixpqrtop, reads in the Mulliken charges into
# the topology files.
#
# Non-linear PB calculations can also be handled if requested so.
#
# By default water (WAT or HOH) and counterions (Na+ or Cl-) are removed for the energy calculations
# excepting the solute-solvent VDW term which uses the water coordinates.
#
# Usage:
#
# bash run_mmpbsa.sh LIST
#
# where LIST is a file containing the list of snapshot PDBs 
# For example,
#
#    snap_0001.pdb
#    snap_0002.pdb
#    snap_0003.pdb
#    snap_0003.pdb
#    ....
#
# All the parameters and settings needed to carry out the calculations
# must be specified in ENV variables. See "USER SPECIFICATION OF CONTROL VARIABLES" below.
#
# On output, calc_energy_analyses.sh produces for every snapshot several gzipped *.out files 
# generated by SANDER. For example, if CMPLX_MASK, HOST_MASK and LIG_MASK are given, 
# there are 5 files for each PDB snapshot:
#
#   snap_0001.out1     ...(MM output file for complex+water shell)
#   snap_0001.out2     ...(MM output file for the water shell alone)
#   snap_0001.out3     ...(concatenated MM and PB output files for the CMPLEX system)
#   snap_0001.out4     ...(concatenated MM and PB output files for the FRAG[1]system)
#   snap_0001.out5     ...(concatenated MM and PB output files for the FRAG[2]system)
#   ........
#
#  An additional file is produced for QMMM calcs reporting details of the preliminary energy minimization.
#  ....  
#  The Information contained in the *.out[1-5] files must be processed usig the "do_energy_analyses.sh" 
#  and "do_stat.sh" scripts 
#

#Working directory 
export WORKDIR=$PWD

################ BEGINNING OF USER SPECIFICATION OF CONTROL VARIABLES #######################
#
# IT MAY BE POSSIBLE TO PREPARE THE INPUT PDB BY USING A CUSTOM SCRIPT DEFINED BY
# THE PREPARE_SNAP variable
#
# PREPARE_SNAP="DUMMY_PREPARE" 
#
# NOTE THAT IN CASE OF PREPARING THE SNAP BOTH THE RESIDUE NUMBERING AND THE
# REFERENCE TOPOLOGY MUST BE IN CONSONANCE WITH THE PREPARED SYSTEM
#
# MASK DEFINITION OF CMPLX and FRAG SUBSYTEMS....
declare -a FRAG_MASK=""
declare -a WAT_FRAG_MASK=""
declare -a NWAT_FRAG=""

CMPLX_MASK="DUMMY_CMPLX_MASK"

# Leave NFRAG="0" if no fragments are defined
NFRAG="DUMMY_NFRAG" 
FRAG_MASK[1]="DUMMY_FRAG_01"
FRAG_MASK[2]="DUMMY_FRAG_02"
FRAG_MASK[3]="DUMMY_FRAG_03"
FRAG_MASK[4]="DUMMY_FRAG_04"
FRAG_MASK[5]="DUMMY_FRAG_05"
FRAG_MASK[6]="DUMMY_FRAG_06"
FRAG_MASK[7]="DUMMY_FRAG_07"
FRAG_MASK[8]="DUMMY_FRAG_08"
FRAG_MASK[9]="DUMMY_FRAG_09"
FRAG_MASK[10]="DUMMY_FRAG_10"
FRAG_MASK[11]="DUMMY_FRAG_11"
FRAG_MASK[12]="DUMMY_FRAG_12"
FRAG_MASK[13]="DUMMY_FRAG_13"
FRAG_MASK[14]="DUMMY_FRAG_14"
FRAG_MASK[15]="DUMMY_FRAG_15"
FRAG_MASK[16]="DUMMY_FRAG_16"
FRAG_MASK[17]="DUMMY_FRAG_17"
FRAG_MASK[18]="DUMMY_FRAG_18"
FRAG_MASK[19]="DUMMY_FRAG_19"
FRAG_MASK[20]="DUMMY_FRAG_20"

# WATERS to be included in FRAGMENT definitions
# NWAT_FRAG molecules around WAT_FRAG_MASK atoms are
# selected using the closestwaters tool in cpptraj
# If is possible to define several sites per fragment separated by semicolons.
# For example WAT_FRAG_MASK[1]=":1@NA ; :3@OG" 
#             NWAT_FRAG[1]=" 2  ;  4 " 
# WARNING: Residue numbering of CMPLX ! 

WAT_FRAG_MASK[1]="DUMMY_WAT_FRAG_01"
WAT_FRAG_MASK[2]="DUMMY_WAT_FRAG_02"
WAT_FRAG_MASK[3]="DUMMY_WAT_FRAG_03"
WAT_FRAG_MASK[4]="DUMMY_WAT_FRAG_04"
WAT_FRAG_MASK[5]="DUMMY_WAT_FRAG_05"
WAT_FRAG_MASK[6]="DUMMY_WAT_FRAG_06"
WAT_FRAG_MASK[7]="DUMMY_WAT_FRAG_07"
WAT_FRAG_MASK[8]="DUMMY_WAT_FRAG_08"
WAT_FRAG_MASK[9]="DUMMY_WAT_FRAG_09"
WAT_FRAG_MASK[10]="DUMMY_WAT_FRAG_10"
WAT_FRAG_MASK[11]="DUMMY_WAT_FRAG_11"
WAT_FRAG_MASK[12]="DUMMY_WAT_FRAG_12"
WAT_FRAG_MASK[13]="DUMMY_WAT_FRAG_13"
WAT_FRAG_MASK[14]="DUMMY_WAT_FRAG_14"
WAT_FRAG_MASK[15]="DUMMY_WAT_FRAG_15"
WAT_FRAG_MASK[16]="DUMMY_WAT_FRAG_16"
WAT_FRAG_MASK[17]="DUMMY_WAT_FRAG_17"
WAT_FRAG_MASK[18]="DUMMY_WAT_FRAG_18"
WAT_FRAG_MASK[19]="DUMMY_WAT_FRAG_19"
WAT_FRAG_MASK[20]="DUMMY_WAT_FRAG_20"

NWAT_FRAG[1]="DUMMY_NWAT_FRAG_01"
NWAT_FRAG[2]="DUMMY_NWAT_FRAG_02"
NWAT_FRAG[3]="DUMMY_NWAT_FRAG_03"
NWAT_FRAG[4]="DUMMY_NWAT_FRAG_04"
NWAT_FRAG[5]="DUMMY_NWAT_FRAG_05"
NWAT_FRAG[6]="DUMMY_NWAT_FRAG_06"
NWAT_FRAG[7]="DUMMY_NWAT_FRAG_07"
NWAT_FRAG[8]="DUMMY_NWAT_FRAG_08"
NWAT_FRAG[9]="DUMMY_NWAT_FRAG_09"
NWAT_FRAG[10]="DUMMY_NWAT_FRAG_10"
NWAT_FRAG[11]="DUMMY_NWAT_FRAG_11"
NWAT_FRAG[12]="DUMMY_NWAT_FRAG_12"
NWAT_FRAG[13]="DUMMY_NWAT_FRAG_13"
NWAT_FRAG[14]="DUMMY_NWAT_FRAG_14"
NWAT_FRAG[15]="DUMMY_NWAT_FRAG_15"
NWAT_FRAG[16]="DUMMY_NWAT_FRAG_16"
NWAT_FRAG[17]="DUMMY_NWAT_FRAG_17"
NWAT_FRAG[18]="DUMMY_NWAT_FRAG_18"
NWAT_FRAG[19]="DUMMY_NWAT_FRAG_19"
NWAT_FRAG[20]="DUMMY_NWAT_FRAG_20"

# WATER PEEL if required a water shell of thickness PEEL is prepared 
DO_PEEL="DUMMY_DO_PEEL"
PEEL="DUMMY_PEEL"

# QM_MASKS and QM_CHARGE (for SCC-DFTB, QMMM ). These variables should be null ("") or commented
# unless SCC-DFTB calculations are required. Note thar residue numbering is
# local in each fragment
#
# Selected waters will be added as QM atoms to the corresponding QM_FRAG_MASK 
# variable as long as QM_ADD_WAT_FRAG == "YES"
#

QM_CMPLX_MASK="DUMMY_QM_CMPLX_MASK"
QM_CMPLX_CHARGE="DUMMY_QM_CMPLX_CHARGE"

declare -a QM_FRAG_MASK=""
QM_FRAG_MASK[1]="DUMMY_QM_FRAG_MASK_01"
QM_FRAG_MASK[2]="DUMMY_QM_FRAG_MASK_02"
QM_FRAG_MASK[3]="DUMMY_QM_FRAG_MASK_03"
QM_FRAG_MASK[4]="DUMMY_QM_FRAG_MASK_04"
QM_FRAG_MASK[5]="DUMMY_QM_FRAG_MASK_05"
QM_FRAG_MASK[6]="DUMMY_QM_FRAG_MASK_06"
QM_FRAG_MASK[7]="DUMMY_QM_FRAG_MASK_07"
QM_FRAG_MASK[8]="DUMMY_QM_FRAG_MASK_08"
QM_FRAG_MASK[9]="DUMMY_QM_FRAG_MASK_09"
QM_FRAG_MASK[10]="DUMMY_QM_FRAG_MASK_10"
QM_FRAG_MASK[11]="DUMMY_QM_FRAG_MASK_11"
QM_FRAG_MASK[12]="DUMMY_QM_FRAG_MASK_12"
QM_FRAG_MASK[13]="DUMMY_QM_FRAG_MASK_13"
QM_FRAG_MASK[14]="DUMMY_QM_FRAG_MASK_14"
QM_FRAG_MASK[15]="DUMMY_QM_FRAG_MASK_15"
QM_FRAG_MASK[16]="DUMMY_QM_FRAG_MASK_16"
QM_FRAG_MASK[17]="DUMMY_QM_FRAG_MASK_17"
QM_FRAG_MASK[18]="DUMMY_QM_FRAG_MASK_18"
QM_FRAG_MASK[19]="DUMMY_QM_FRAG_MASK_19"
QM_FRAG_MASK[20]="DUMMY_QM_FRAG_MASK_20"

declare -a QM_CHARGE_FRAG=""
QM_CHARGE_FRAG[1]="DUMMY_QM_CHARGE_FRAG_01"
QM_CHARGE_FRAG[2]="DUMMY_QM_CHARGE_FRAG_02"
QM_CHARGE_FRAG[3]="DUMMY_QM_CHARGE_FRAG_03"
QM_CHARGE_FRAG[4]="DUMMY_QM_CHARGE_FRAG_04"
QM_CHARGE_FRAG[5]="DUMMY_QM_CHARGE_FRAG_05"
QM_CHARGE_FRAG[6]="DUMMY_QM_CHARGE_FRAG_06"
QM_CHARGE_FRAG[7]="DUMMY_QM_CHARGE_FRAG_07"
QM_CHARGE_FRAG[8]="DUMMY_QM_CHARGE_FRAG_08"
QM_CHARGE_FRAG[9]="DUMMY_QM_CHARGE_FRAG_09"
QM_CHARGE_FRAG[10]="DUMMY_QM_CHARGE_FRAG_10"
QM_CHARGE_FRAG[11]="DUMMY_QM_CHARGE_FRAG_11"
QM_CHARGE_FRAG[12]="DUMMY_QM_CHARGE_FRAG_12"
QM_CHARGE_FRAG[13]="DUMMY_QM_CHARGE_FRAG_13"
QM_CHARGE_FRAG[14]="DUMMY_QM_CHARGE_FRAG_14"
QM_CHARGE_FRAG[15]="DUMMY_QM_CHARGE_FRAG_15"
QM_CHARGE_FRAG[16]="DUMMY_QM_CHARGE_FRAG_16"
QM_CHARGE_FRAG[17]="DUMMY_QM_CHARGE_FRAG_17"
QM_CHARGE_FRAG[18]="DUMMY_QM_CHARGE_FRAG_18"
QM_CHARGE_FRAG[19]="DUMMY_QM_CHARGE_FRAG_19"
QM_CHARGE_FRAG[20]="DUMMY_QM_CHARGE_FRAG_20"

declare -a QM_ADD_WAT_FRAG=""
QM_ADD_WAT_FRAG[1]="DUMMY_QM_ADD_WAT_FRAG_01"
QM_ADD_WAT_FRAG[2]="DUMMY_QM_ADD_WAT_FRAG_02"
QM_ADD_WAT_FRAG[3]="DUMMY_QM_ADD_WAT_FRAG_03"
QM_ADD_WAT_FRAG[4]="DUMMY_QM_ADD_WAT_FRAG_04"
QM_ADD_WAT_FRAG[5]="DUMMY_QM_ADD_WAT_FRAG_05"
QM_ADD_WAT_FRAG[6]="DUMMY_QM_ADD_WAT_FRAG_06"
QM_ADD_WAT_FRAG[7]="DUMMY_QM_ADD_WAT_FRAG_07"
QM_ADD_WAT_FRAG[8]="DUMMY_QM_ADD_WAT_FRAG_08"
QM_ADD_WAT_FRAG[9]="DUMMY_QM_ADD_WAT_FRAG_09"
QM_ADD_WAT_FRAG[10]="DUMMY_QM_ADD_WAT_FRAG_10"
QM_ADD_WAT_FRAG[11]="DUMMY_QM_ADD_WAT_FRAG_11"
QM_ADD_WAT_FRAG[12]="DUMMY_QM_ADD_WAT_FRAG_12"
QM_ADD_WAT_FRAG[13]="DUMMY_QM_ADD_WAT_FRAG_13"
QM_ADD_WAT_FRAG[14]="DUMMY_QM_ADD_WAT_FRAG_14"
QM_ADD_WAT_FRAG[15]="DUMMY_QM_ADD_WAT_FRAG_15"
QM_ADD_WAT_FRAG[16]="DUMMY_QM_ADD_WAT_FRAG_16"
QM_ADD_WAT_FRAG[17]="DUMMY_QM_ADD_WAT_FRAG_17"
QM_ADD_WAT_FRAG[18]="DUMMY_QM_ADD_WAT_FRAG_18"
QM_ADD_WAT_FRAG[19]="DUMMY_QM_ADD_WAT_FRAG_19"
QM_ADD_WAT_FRAG[20]="DUMMY_QM_ADD_WAT_FRAG_20"

# D3H4 corrections can be incorporated to SCC-DFTB3 energies
# provided that DFTB+ and CUBY4 are available
QM_ADD_D3H4="DUMMY_D3H4"


# ORCA DETAILS ...
QM_ORCA="DUMMY_QM_ORCA"
QM_ORCA_RELAX="DUMMY_QM_ORCA_RELAX"
QM_ORCA_LEVEL="DUMMY_QM_ORCA_LEVEL"
QM_ORCA_RELAX_LEVEL="DUMMY_QM_ORCA_OPT_LEVEL"
NPROCS_ORCA="DUMMY_NPROCS_QM"
# Choosing between SCC-DFTB and ORCA settings
if [ "$QM_ORCA" == "YES" ]
then
    QM_METHOD="EXTERN"
# Choose here the level of theory 
    echo ' &orc                       ' >> ${WORKDIR}/orc.info
    echo '     maxcore=2024,          ' >> ${WORKDIR}/orc.info
    echo '     convkey="tightscf"     ' >> ${WORKDIR}/orc.info
    echo '     use_template=1,        ' >> ${WORKDIR}/orc.info
    echo "     num_threads=${NPROCS_ORCA}, " >> ${WORKDIR}/orc.info
    echo '   /                        ' >> ${WORKDIR}/orc.info
    mv $WORKDIR/orc.info $WORKDIR/qm.info
else
    QM_METHOD="DFTB3"
fi

# IF available, QM/MM relaxation with TeraChem would be much faster 
# but for simplicity...we keep ORCA SP calcs (we handle ESP charges right away)
QM_TC_RELAX="DUMMY_QM_TC_RELAX"
QM_TC_LEVEL="DUMMY_QM_TC_LEVEL" 
export OMP_NUM_THREADS="DUMMY_NPROCS_QM"    # Leave as 1 for SCC-DFTB3 (do_mmpbsa.sh takes care)
export KMP_NUM_THREADS=$OMP_NUM_THREADS   
if [ $QM_TC_RELAX == "YES" ]
then
    echo ' &tc                       ' >> ${WORKDIR}/orc.info
    echo '     ngpus=1,          ' >> ${WORKDIR}/orc.info
    echo "     gpuids=${GPUID}, " >> ${WORKDIR}/orc.info
    echo '     use_template=1,        ' >> ${WORKDIR}/orc.info
    echo '     charge_analysis="MULLIKEN",' >>  ${WORKDIR}/orc.info
    echo '   /                        ' >> ${WORKDIR}/orc.info
    mv $WORKDIR/orc.info $WORKDIR/tc.info
fi

# REFERENCE TOPOLOGY FILE (must contain more water molecules than any snapshot)
# WE USE CPPTRAJ COMMANDS TO STRIP OFF THE REFERENCE TOPOLOGY FILE AND GET
# THE COORDINATES FOR ANALYSES
#
REFTOP="DUMMY_TOPOLOGY"

# SNAPSHOTS DIRECTORY: contains the gzipped PDB files that are to be processed
SNAP="DUMMY_SNAPSHOTS"

# REFERENCE PDB FILE for superposition purposes. This is not required, but
# it might be convenient to minimize the impact of grid noise. The PDB
# file must contain coordinates of the solute atoms (alias "cmplx") 
# One MASK for superposition is also needed. If REFPDB="" then
# no superposition is undertaken. 

#REFPDB=""
#REFMASK=""

# By default linear PB calcs are performed. For non-linear PB calculations.
# Change PBNL to YES if non-linear PB are required
PBNL="YES" 
ISTRNG="DUMMY_ISTRNG"    # Ionic strength in mM units
PDIE="DUMMY_PDIE" 

# CAVITY/SURF calculations may or not include WAT/Counterions
EXCL_SOLV_SURFCAV="YES" 

# Sometimes we may have already computed the CMPLX files
# and want to compute only the frag_${ifrag}/lig files. In this case
# change SKIPCMPLX to yes
SKIPCMPLX="DUMMY_SKIPCMPLX" 

# Othertimes we may have already computed the FRAG files
# and want to compute only the CMPLX files
# change SKIPFRAG to yes
SKIPFRAG="DUMMY_SKIPFRAG"

# Use 3D-RISM method as implemented in SANDER. This is only feasible if
# QM methods are NOT used. Note also that RISM deactivates PB calcs...
# 
RISM="DUMMY_RISM" 
XVVFILE="DUMMY_XVVFILE" 

# AUTODOCK Scoring function 
# TEMPLATE files for each fragment are required 
# AUTODOCK deactivates both PB and RISM options 
ADCK="DUMMY_ADCK"
ADCK_ONLY="DUMMY_ADCK_ONLY"
GRID="0.333"
PDBQT_WAT="DUMMY_PDBQT_WAT"
PDBQT_NA="DUMMY_PDBQT_NA"
declare -a PDBQT_FRAG=""
PDBQT_FRAG[1]="DUMMY_PDBQT_FRAG_01"
PDBQT_FRAG[2]="DUMMY_PDBQT_FRAG_02"
PDBQT_FRAG[3]="DUMMY_PDBQT_FRAG_03"
PDBQT_FRAG[4]="DUMMY_PDBQT_FRAG_04"
PDBQT_FRAG[5]="DUMMY_PDBQT_FRAG_05"
PDBQT_FRAG[6]="DUMMY_PDBQT_FRAG_06"
PDBQT_FRAG[7]="DUMMY_PDBQT_FRAG_07"
PDBQT_FRAG[8]="DUMMY_PDBQT_FRAG_08"
PDBQT_FRAG[9]="DUMMY_PDBQT_FRAG_09"
PDBQT_FRAG[10]="DUMMY_PDBQT_FRAG_10"
PDBQT_FRAG[11]="DUMMY_PDBQT_FRAG_11"
PDBQT_FRAG[12]="DUMMY_PDBQT_FRAG_12"
PDBQT_FRAG[13]="DUMMY_PDBQT_FRAG_13"
PDBQT_FRAG[14]="DUMMY_PDBQT_FRAG_14"
PDBQT_FRAG[15]="DUMMY_PDBQT_FRAG_15"
PDBQT_FRAG[16]="DUMMY_PDBQT_FRAG_16"
PDBQT_FRAG[17]="DUMMY_PDBQT_FRAG_17"
PDBQT_FRAG[18]="DUMMY_PDBQT_FRAG_18"
PDBQT_FRAG[19]="DUMMY_PDBQT_FRAG_19"
PDBQT_FRAG[20]="DUMMY_PDBQT_FRAG_20"

# The list of input PDB files (without the .gz extension)
# is read as an argument for the script 
files=$1

########################## END OF USER-SPECIFICATION OF CONTROL VARIABLES ###################33
# Programs being used    
#
# AMBER
LD_LIBRARY_PATH=$AMBERHOME/lib:$LD_LIBRARY_PATH
SANDER="$AMBERHOME/bin/sander"
PBSA="$AMBERHOME/bin/pbsa"
PARMED="$AMBERHOME/bin/parmed -n"
CPPTRAJ="$AMBERHOME/bin/cpptraj"
AMBMASK="$AMBERHOME/bin/ambmask"


# ORCA (for QM/MM calcs)
if [ $QM_ORCA  == "YES" ]
then
   if [ -z $ORCA ]; then echo "ORCA not defined, but needed!"; exit; fi
   export PATH=$MPI_HOME/bin/:$ORCA:$PATH
   export LD_LIBRARY_PATH=$MPI_HOME/lib:$ORCA:$LD_LIBRARY_PATH
   export OMPI_MCA_mca_base_component_show_load_errors=0
fi

# TC (for QM/MM calcs) 
if [ $QM_TC_RELAX == "YES" ]
then
  if [ -z $TeraChem ]; then echo "TeraChem not defined, but needed!"; exit; fi 
  export NBOEXE=$TeraChem/bin/nbo6.i4.exe
  export LD_LIBRARY_PATH=$TeraChem/lib:$LD_LIBRARY_PATH
  export PATH=$TeraChem/bin:$PATH
fi

# MSMS
if [ -z $MSMS ]; then echo "MSMS nore defined, but needed!"; exit; fi 

# AUTODOCK
if [ $ADCK == "YES" ]
then
   if [ -z $ADFR ]; then echo "ADFR not defined, but needed"; exit; fi 
   PYTHONSH="$ADFR/bin/pythonsh"
fi

# Auxiliary programs (in house; other tools could be used)
PDBCRD="$TOOLS/pdbcrd"
REORDER="$TOOLS/reorder"
FIXPQRTOP="$TOOLS/fixpqrtop"
GCAV="$TOOLS/gcav"

# TEMP Directories
TT=$(date +%N)
TMPDIR=${SCRATCH}/TMPDIR_${TT} 

# All work is done in a temporal directory
mkdir $TMPDIR
cd $TMPDIR

# SANDER input for sigle-point MM calculations
echo 'single point' > sander.inp
echo ' &cntrl' >> sander.inp
echo '  imin=1, maxcyc=0,' >> sander.inp
echo '  ntb=0, ntf=1, ntc=1, igb=6 ' >> sander.inp
echo '  cut=999., ' >> sander.inp
echo ' &end' >> sander.inp

# SANDER input for sigle-point MM-GB calculations
SALTCON=$(echo ${ISTRNG}/1000 | bc -l)
echo 'single point' > sander_mmgb.inp
echo ' &cntrl' >> sander_mmgb.inp
echo '  imin=1, maxcyc=0,' >> sander_mmgb.inp
echo '  ntb=0, ntf=1, ntc=1, ' >> sander_mmgb.inp
echo '  igb=1, gbsa=1,' >> sander_mmgb.inp
echo "  extdiel=80.0, intdiel=${PDIE}, saltcon=${SALTCON} " >> sander_mmgb.inp
echo '  cut=999., rgbmax=999. ' >> sander_mmgb.inp
echo ' &end' >> sander_mmgb.inp

# SANDER input for sigle-point 3D-RISM calculations  
echo 'single point' > sander_mmrism.inp
echo ' &cntrl' >> sander_mmrism.inp
echo '  imin=1, maxcyc=0,' >> sander_mmrism.inp
echo '  ntb=0, ntf=1, ntc=1, ' >> sander_mmrism.inp
echo '  cut=999., ' >> sander_mmrism.inp
echo '  irism=1, ' >> sander_mmrism.inp
echo '/' >> sander_mmrism.inp
echo '&rism' >> sander_mmrism.inp
echo 'closure="KH",' >> sander_mmrism.inp
echo 'asympcorr=.T., buffer=15.0,' >> sander_mmrism.inp
echo 'centering=2,' >> sander_mmrism.inp
echo 'grdspc=0.3333,0.3333,0.3333,' >> sander_mmrism.inp
echo 'mdiis_nvec=10,' >> sander_mmrism.inp
echo 'ntwrism=0, verbose=1, write_thermo=1,' >> sander_mmrism.inp
echo 'pcpluscorrection=1,' >> sander_mmrism.inp
echo 'tolerance=1e-4, !Saves some time compared to 1e-5' >> sander_mmrism.inp
echo 'apply_rism_force=0, !Saves some time. Forces are not used.' >> sander_mmrism.inp
echo 'npropagate=1 !Saves some time and 4*8*Nbox bytes' >> sander_mmrism.inp
echo '/'>> sander_mmrism.inp


# PBSA input for linear   MM-PB single-point calculations  (CAV+Edis non-polar solvation)
echo 'single point' > pbsa_lin.inp
echo ' &cntrl' >> pbsa_lin.inp
echo '  ipb=1, inp=2, ' >> pbsa_lin.inp
echo '&end' >> pbsa_lin.inp
echo '&pb'>>pbsa_lin.inp
echo ' frcopt = 0 '>>pbsa_lin.inp
echo " epsin  = ${PDIE},     epsout  = 80.0,">>pbsa_lin.inp
echo " istrng = ${ISTRNG},       radiopt = 0,">>pbsa_lin.inp
echo ' sprob  = 1.4,     space   = 0.33333,'>>pbsa_lin.inp
echo ' maxitn = 1000,     '>>pbsa_lin.inp
echo ' npbverb= 0,'>>pbsa_lin.inp
echo '&end'>>pbsa_lin.inp

# PBSA input for non-linear MM-PB single-point calculations (CAV+Edis non-polar solvation)
echo 'single point' > pbsa.inp
echo ' &cntrl' >> pbsa.inp
echo '  ipb=1, inp=2, ' >> pbsa.inp
echo '&end' >> pbsa.inp
echo '&pb'>>pbsa.inp
echo ' npbopt= 1, '>>pbsa.inp
echo ' eneopt= 1, '>>pbsa.inp
echo ' bcopt= 6, '>>pbsa.inp
echo ' cutnb= 99.0, '>>pbsa.inp
echo ' frcopt = 0, '>>pbsa.inp
echo ' phiout = 0, '>>pbsa.inp
echo ' phiform = 0, '>>pbsa.inp
echo " epsin  = ${PDIE},     epsout= DUMMY_EPS, ">>pbsa.inp
echo " istrng =  ${ISTRNG},      radiopt= 0,">>pbsa.inp
echo ' sprob  = 1.4,    space  = 0.25   ,'>>pbsa.inp
echo ' maxitn = 5000,     '>>pbsa.inp
echo ' npbverb= 1,'>>pbsa.inp
echo '&end'>>pbsa.inp

sed 's/DUMMY_EPS/80.0/' pbsa.inp > pbsa_e80.inp


# CUBY4 YAML file for D3H4 calcs

if [ "${QM_ADD_D3H4}" == "YES" ]
then
   if [ -z $CUBY4 ]
   then
       echo "CUBY4 variable not defined!"
       QM_ADD_D3H4="NO"
   fi
fi

if [ "${QM_ADD_D3H4}" == "YES" ]
then

cat <<EOF >  input_cuby4.yaml 
job: multistep
steps: uffuncorrected, uffcorrected
calculation_common:
  job: energy
  geometry: temp.xyz

calculation_uffuncorrected:
  interface: uff
calculation_uffcorrected:
  interface: uff
  modifiers: dispersion3, h_bonds4
# Dispersion3 setup
  modifier_dispersion3:
    d3_damping: :zero
    d3_sr6: 1.25
    d3_alpha6: 29.61
    d3_s8: 0.49
  # Hydrogen-hydrogen repulsion:
    d3_hh_fix: yes
    d3_hh_para:
       :k: 0.30
       :e: 14.31
       :r0: 2.35
# H4 correction setup, including the additional
# scaling for charged systems
  modifier_h_bonds4:
    h_bonds4_parameters:
      oh_o: 1.28
      oh_n: 3.84
      nh_o: 0.88
      nh_n: 2.83
      multiplier_wh_o: 1.00
      multiplier_coo: 1.75
      multiplier_nh4: 4.01
    h_bonds4_extra_scaling:
      "@N&:hip": 3.44
      "@N&:gua": 2.68

EOF

fi


################################################################################
# AUTODOCK TEMPLATE FILES 
################################################################################
if [ "$ADCK" == "YES"  ]   &&  [ "$NFRAG" -gt  1 ]
then

for ((IFRAG=2;IFRAG<=NFRAG;IFRAG++))
do

  let "ISITE=$IFRAG-1"
  if [ ! -e ${PDBQT_FRAG[1]} ] ; then echo "${PDBQT_FRAG[1]} does not exist!"; exit; fi
  cp ${PDBQT_FRAG[1]} REC_template_${ISITE}.pdbqt
  if [ ! -e ${PDBQT_FRAG["$IFRAG"]} ] ; then echo "${PDBQT_FRAG["$IFRAG"]} does not exist!"; exit; fi
  cp ${PDBQT_FRAG["$IFRAG"]} LIG_template_${ISITE}.pdbqt

  for ((JFRAG=2;JFRAG<=NFRAG;JFRAG++))
  do
     if [ "$JFRAG" -ne "$IFRAG" ]
     then
        if [ ! -e ${PDBQT_FRAG["$JFRAG"]} ] ; then echo "${PDBQT_FRAG["$JFRAG"]} does not exist!"; exit; fi
        grep 'ATOM ' ${PDBQT_FRAG["$JFRAG"]}  >> REC_template_${ISITE}.pdbqt
     fi
  done

  if [ ! -e ${PDBQT_WAT} ] ; then echo "${PDBQT_WAT} does not exist!"; exit; fi
  if [ ! -e ${PDBQT_NA} ] ; then echo "${PDBQT_NA} does not exist!"; exit; fi

  $REORDER < REC_template_${ISITE}.pdbqt > tmp.pdbqt; mv tmp.pdbqt REC_template_${ISITE}.pdbqt

# echo '# PREFIX E_INT_ADCK' > $WORKDIR/E_INT_ADCK_${ISITE}.dat

done

fi
################################################################################

# We discount waters and counterions from the total number of residues
# in REFTOP  in order to find the number of "cmplx" residues (i.e., non-solvent) 

sed '1,/FLAG RESIDUE_LABEL/d' $REFTOP | sed '/FLAG/,$d' > RESLAB.dat
MAXWAT=$(grep 'WAT\|HOH' RESLAB.dat  | tr " \t" "\n" | grep -c 'WAT\|HOH' )
MAXNA=$(grep 'Na+' RESLAB.dat  | tr " \t" "\n" | grep -c 'Na+')
MAXCL=$(grep 'Cl-' RESLAB.dat | tr " \t" "\n" | grep -c 'Cl-')
POINTERS=($(grep 'FLAG POINTERS' -A 4 $REFTOP |tail -3)) 
MAXRES_REFTOP=${POINTERS[11]} 

let " NRES = $MAXRES_REFTOP - $MAXWAT - $MAXNA - $MAXCL " 

echo " $REFTOP has $NRES non-solvent resdidues, $MAXWAT waters, $MAXNA Na+ and $MAXCL Cl-" 

#REF topology is stripped from counterions and box information
$PARMED $REFTOP <<EOF
strip :Na+,Cl-
parmout REF.top
go
EOF
$CPPTRAJ REF.top <<EOF
parmbox nobox
parmwrite out REF.top
go
EOF
REFTOP="./REF.top"

#=======================================================================================
# Big loop over input PDB files 
#=======================================================================================

N_SELECTED_WATERS=0
for  i  in $(cat $WORKDIR/$files)
do

#Cleaning up
rm -f  *.crd *.rst *.pqr *.pdb 
rm -f temp.*
# Topologies of cmplx, frag_${ifrag}, lig can be reutilized if no waters are
# selected in the fragments....
rm -f cmplxwat.top wat.top 
if [ "$N_SELECTED_WATERS" -gt 0 ] 
then 
   rm -f cmplx.top frag_*.top
fi 

# The following IF can be useful when resubmitting unfinished jobs
# so that only those PDB files for which no output is already available
# will be processed

if [ ! -e $WORKDIR/${i/.pdb/.out1.gz} ]
then 

# Uncompressing input PDB file
zcat  $SNAP/$i   > $i

# Copy RISM XVV file if needed
if [ "$RISM" == "YES" ]; then cp $XVVFILE  solvent.xvv ; fi 

# PREPARE task here 
if [ "$PREPARE_SNAP" ]
then 
  echo "Preparing snapshot"
  bash $PREPARE_SNAP $i
fi
mv $i temp.pdb 

# Reordering 
sed -i 's/ W.. / WAT /' temp.pdb
$REORDER  < temp.pdb > temp2.pdb ; mv temp2.pdb temp.pdb 
NWAT=$(grep -c 'O   WAT' temp.pdb) 

# Peeling 
if [ "${DO_PEEL}" == "YES" ]  && [ $MAXWAT -ge $NWAT ] 
then
     echo "Performing a peeling operation PEEL=$PEEL"
     # Preparing topology file for peeling 
     let " ARES = $NRES + $NWAT +  1 "
     let " BRES = $NRES + $MAXWAT "
     $PARMED  $REFTOP <<EOF
strip :${ARES}-${BRES}
parmout cmplxwat0.top 
go
EOF
    $CPPTRAJ cmplxwat0.top <<EOF
trajin  temp.pdb
watershell !:WAT,Na+,Cl-  lower ${PEEL}  upper  ${PEEL}  out temp.iswat
go 
EOF
   NWAT_IN=$(grep -v '#' temp.iswat | awk '{print $2}')
   $CPPTRAJ cmplxwat0.top <<EOF
trajin  temp.pdb
trajout temp_peeled.pdb pdb vdw include_ep
closest ${NWAT_IN} !:WAT,Na+,Cl- solventmask :WAT@O,Na+,Cl- 
go
EOF
   mv -f temp_peeled.pdb temp.pdb 
   rm -f cmplxwat0.top
   unset NWAT ARES BRES NWAT_IN
fi

# Separate waters and cmplx 
grep WAT temp.pdb | grep 'ATOM '  >  wat.pdb
grep -v WAT temp.pdb > cmplx.pdb 
mv temp.pdb cmplxwat.pdb
NWAT=$(grep -c 'O   WAT' wat.pdb) 

# Preparing TOPOLOGY files for MMPBSA calcs
if [ "$MAXWAT" -gt "0" ] && [ "$NWAT" -gt "0" ]
then

  if [ "$NWAT" -lt "$MAXWAT" ]
  then

     let " ARES = $NRES + $NWAT +  1 "
     let " BRES = $NRES + $MAXWAT "
     $PARMED  $REFTOP <<EOF
strip :${ARES}-${BRES}
parmout cmplxwat.top 
go
EOF

  else

    cp  $REFTOP cmplxwat.top 

  fi

else

cp  $REFTOP cmplxwat.top 
cp  $REFTOP cmplx.top

fi

#Selecting fragment waters
declare -a NEW_FRAG_MASK=""
declare -a NEW_QM_FRAG_MASK=""
SELECTED_WATER=""
N_SELECTED_WATERS=0

let " TOTAL_RES = $NRES + $MAXWAT "

# Checking number of MOL fragments
$CPPTRAJ cmplxwat.top << EOF
trajin   cmplxwat.pdb 
trajout  cmplx.pdb dumpq include_ep
strip  :WAT
go
EOF
NMOL=$(grep -c 'TER' cmplx.pdb)

# There may be repeated waters
declare -a IDWAT_CHECK=""
for ((ires=0;ires<=TOTAL_RES;ires++));do IDWAT_CHECK["$ires"]=0; done

for ((ifrag=1;ifrag<=NFRAG;ifrag++))
do

   declare -a NWFR=""
   declare -a MASK_FR=""
   declare -a QM_MASK_FR=""
   echo ${NWAT_FRAG["$ifrag"]}
   echo ${WAT_FRAG_MASK["$ifrag"]} 
   NWFR=($(echo ${NWAT_FRAG["$ifrag"]} | sed 's/;/  /g'))
   MASK_FR=($(echo ${WAT_FRAG_MASK["$ifrag"]} | sed 's/;/  /g'))  
   NSITE_NW=${#NWFR[@]}  
   NSITE_MASK=${#MASK_FR[@]}  

   echo " NWFR=${NWFR[*]}  MASK=${MASK_FR[*]}  NSITE_NW=${NSITE_NW} NSITE_MASK=${NSITE_MASK}"

   if [ "$NSITE_NW" -gt 0 ] &&  [ ${NWFR[0]} -gt 0 ]
   then

   if [ ${NSITE_NW} -ne ${NSITE_MASK} ]; then echo "Inconsistent definitions of NWFR, MASK, NSITE_NW, NSITE_MASK "; exit; fi

   DUMMY_WAT_MASK=""
   for ((ISITE=0;ISITE<=NSITE_NW-1;ISITE++))
   do

       NWFR_site=${NWFR["$ISITE"]}
       MASK_site=${MASK_FR["$ISITE"]}
       let "NWFR_get = 8 * $NWFR_site"
     
$CPPTRAJ cmplxwat.top << EOF
trajin cmplxwat.pdb 
closest $NWFR_get $MASK_site closestout temp.frwat
go
EOF

       declare -a DUMMY_WAT_IN_FRAG=""
       DUMMY_WAT_IN_FRAG=($(grep -v '#' temp.frwat | awk -v nres=$NRES -v nmol=$NMOL   '{print $2 + nres -nmol}'))
       echo "${DUMMY_WAT_IN_FRAG[*]}"
       
       for ((iwat=1;iwat<=NWFR_site;iwat++))
       do
         let " jwat = $iwat - 1"
         kwat=${DUMMY_WAT_IN_FRAG["$jwat"]}
 
#  For consistency, the same number of water molecules
#  should be picked up. We try to catch a second shell water
         if [ ${IDWAT_CHECK["$kwat"]} -eq 1 ]
         then
            for ((iwat_B=1;iwat_B<=7*NWFR_site;iwat_B++))
            do
                 let " jwat_B =  $NWFR_site + $iwat_B - 1"
                 kwat_B=${DUMMY_WAT_IN_FRAG["$jwat_B"]}
                 if [ ${IDWAT_CHECK["$kwat_B"]} -eq 0 ]
                 then
                     kwat=$kwat_B
                     break
                 fi
            done
         fi
   
         if [ ${IDWAT_CHECK["$kwat"]} -eq 0 ]
         then  
            DUMMY_WAT_MASK=${DUMMY_WAT_MASK}","${kwat}
            SELECTED_WATER=${SELECTED_WATER}","${kwat}
            let " N_SELECTED_WATERS= $N_SELECTED_WATERS + 1 "
            IDWAT_CHECK["$kwat"]="1"
         fi

       done
       MASK=${FRAG_MASK["$ifrag"]}
       NEW_FRAG_MASK["$ifrag"]=${DUMMY_WAT_MASK}   # so far only waters, later we put the solute

   done 

   if [ "$QM_CMPLX_MASK" != "" ] &&  [ ${QM_FRAG_MASK["$ifrag"]} != "" ] ; then NEW_QM_FRAG_MASK["$ifrag"]="${QM_FRAG_MASK["$ifrag"]} | :WAT"; fi 

  else
    MASK=${FRAG_MASK["$ifrag"]}
    NEW_FRAG_MASK["$ifrag"]=${MASK} 
    if [ "$QM_CMPLX_MASK" != "" ] &&  [ ${QM_FRAG_MASK["$ifrag"]} != "" ] ; then NEW_QM_FRAG_MASK["$ifrag"]="${QM_MASK_FRAG["$ifrag"]}";  fi
  fi

done

# Reordering selected waters
QM_SELECTED_WATER=""
if [ ${N_SELECTED_WATERS} -gt 0 ]
then
   rm -f solute.pdb solvent.pdb selected.pdb
   $PDBCRD  < cmplxwat.pdb > cmplxwat.crd

$CPPTRAJ  cmplxwat.top <<EOF
trajin cmplxwat.crd
trajout selected.pdb pdb  include_ep 
strip  !${CMPLX_MASK}${SELECTED_WATER}
go
EOF

$CPPTRAJ  cmplxwat.top <<EOF
trajin cmplxwat.crd
trajout solvent.pdb pdb include_ep 
strip  ${CMPLX_MASK}${SELECTED_WATER}
go
EOF

$CPPTRAJ  cmplxwat.top <<EOF
trajin cmplxwat.crd
trajout solute.pdb pdb include_ep
strip  !${CMPLX_MASK}
go
EOF

   iwat=${NRES}
   nwat_tot=0
   for ((ifrag=1;ifrag<=NFRAG;ifrag++)) 
   do

      declare -a NWFR=""
      NWFR=($(echo ${NWAT_FRAG["$ifrag"]} | sed 's/;/  /g'))
      NSITE_NW=${#NWFR[@]}
      if [ "$NSITE_NW" -gt 0 ] &&  [ ${NWFR[0]} -gt 0 ]
      then

      rm -f temp_frag_wat.pdb

$CPPTRAJ  cmplxwat.top <<EOF
trajin cmplxwat.crd
trajout temp_frag_wat.pdb pdb  include_ep
strip !:${NEW_FRAG_MASK["$ifrag"]}
go
EOF
     nwat_in_fr=$(grep 'ATOM ' temp_frag_wat.pdb | grep -c 'O   WAT' )
     let "iwat=${iwat}+1"
     let "jwat=${iwat}+${nwat_in_fr}-1" 
     let "nwat_tot=${nwat_tot}+${nwat_in_fr}"

     cat temp_frag_wat.pdb >> solute.pdb   
     MASK=${FRAG_MASK["$ifrag"]}
     NEW_FRAG_MASK["$ifrag"]="${MASK},${iwat}-${jwat}"
     echo "CHECK $ifrag $QM_CMPLX_MASK ${QM_FRAG_MASK["$ifrag"]} "
     if [ "$QM_CMPLX_MASK" != "" ] && [ ${QM_FRAG_MASK["$ifrag"]} != "" ]  && [ ${QM_ADD_WAT_FRAG["$ifrag"]} == "YES" ] 
     then 
        QM_SELECTED_WATER="${QM_SELECTED_WATER},${iwat}-${jwat}"
     fi
     iwat=$jwat

     fi

   done
  
   let "iwat=${NRES}+1"
   let "jwat=${NRES}+${nwat_tot}"
   SELECTED_WATER=",${iwat}-${jwat}"
   cat solute.pdb solvent.pdb > cmplxwat.pdb

fi


if [ "$N_SELECTED_WATERS" -gt "0"  ]
then
   if [ "$QM_CMPLX_MASK" != "" ]  
   then 
       echo "SELECTED_WATER=$SELECTED_WATER"
       echo "QM_SELECTED_WATER=$QM_SELECTED_WATER"
       NEW_QM_CMPLX_MASK_opt="${QM_CMPLX_MASK}${QM_SELECTED_WATER}"
       NEW_QM_CMPLX_MASK_sp="${QM_CMPLX_MASK}${QM_SELECTED_WATER}"
   fi
else
   if [ "$QM_CMPLX_MASK" != "" ]  
   then 
       NEW_QM_CMPLX_MASK_opt="${QM_CMPLX_MASK}"
       NEW_QM_CMPLX_MASK_sp="${QM_CMPLX_MASK}"
   fi
fi

if [ ${SELECTED_WATER:0:1} == "," ]
then
  ncar=${#SELECTED_WATER}
  SELECTED_WATER=":"${SELECTED_WATER:1:ncar}
else
  SELECTED_WATER=":"${SELECTED_WATER}
fi

if [ "$N_SELECTED_WATERS" -gt "0"  ]
then 

$PARMED  cmplxwat.top <<EOF
strip "!:WAT | ${SELECTED_WATER}"
parmout wat.top 
go
EOF

else 

  if [ "$MAXWAT" -gt "0" ] && [ "$NWAT" -gt "0" ]
  then

    $PARMED cmplxwat.top <<EOF
strip "!:WAT"
parmout wat.top 
go
EOF

  else
     touch wat.top
  fi

fi

if [ ! -e "cmplx.top" ] 
then

let " ARES = $NRES + $N_SELECTED_WATERS +  1 "
let " BRES = $NRES + $N_SELECTED_WATERS + $MAXWAT "
$PARMED  $REFTOP <<EOF
strip :${ARES}-${BRES}
parmout cmplx.top 
go
EOF

fi 

if [ "$NFRAG" -gt 1  ] 
then 

  for ((ifrag=1;ifrag<=NFRAG;ifrag++))
  do

    MASK=${NEW_FRAG_MASK["$ifrag"]}
    echo "ifrag=$ifrag  MASK=$MASK"

    if [ ! -e "frag_${ifrag}.top" ]
    then  

      $PARMED  cmplxwat.top <<EOF
strip "!${MASK}"
parmout frag_${ifrag}.top
go
EOF
    fi

  done 

fi

##################### Writing SANDER QMMM input files 
if [ "$QM_CMPLX_MASK" != "" ]
then 

#  SANDER input for MM relaxation of the QM region (in case of QMMM analyses)
  echo 'Minimization  ' > sander_mm_min.inp
  echo '&cntrl  ' >> sander_mm_min.inp
  echo ' imin=1, maxcyc=250,  ntmin=2, drms=0.02 ' >> sander_mm_min.inp
  echo ' ntb=0, ntf=1, ntc=1, ntpr=50, '  >> sander_mm_min.inp
  echo ' cut=20.0, nsnb=50000,  igb=0, ' >> sander_mm_min.inp
  echo " ibelly=1, bellymask=\" ${NEW_QM_CMPLX_MASK_opt} \", " >> sander_mm_min.inp
  echo ' / ' >> sander_mm_min.inp

# SANDER input for SCF test (Only for DFTB3 calcs) 
  echo 'Minimization  ' > sander_scftest.inp
  echo '&cntrl  ' >> sander_scftest.inp
  echo ' imin=1, maxcyc=0,  ntmin=1, drms=0.02 ' >> sander_scftest.inp
  echo ' ntb=0, ntf=1, ntc=1, ntpr=1, '  >> sander_scftest.inp
  echo ' cut=20.0, nsnb=50000,  igb=0, ' >> sander_scftest.inp
  echo ' ifqnt=1, ' >> sander_scftest.inp
  echo ' / ' >> sander_scftest.inp
  echo ' / ' >> sander_scftest.inp
  echo ' &qmmm' >> sander_scftest.inp
  echo "    qmmask=\" ${NEW_QM_CMPLX_MASK_opt} \"," >> sander_scftest.inp
  echo '    qmcut=999.0,' >> sander_scftest.inp
  echo '    qm_ewald=0,' >> sander_scftest.inp
  echo '    qm_theory="DFTB3" ' >> sander_scftest.inp
  echo '    writepdb=1, ' >> sander_scftest.inp
  echo "    qmcharge=${QM_CMPLX_CHARGE}, " >> sander_scftest.inp
  echo '    adjust_q=0, ' >> sander_scftest.inp
  echo '    dftb_disper=0, ' >> sander_scftest.inp
  echo '    dftb_maxiter=500, ' >> sander_scftest.inp
  echo ' &end' >> sander_scftest.inp

# SANDER input for QM/MM  relaxation calculations 
  echo 'single point' > sander_qmmm_min.inp
  echo ' &cntrl' >> sander_qmmm_min.inp
  echo '  imin=1, ntmin=3, maxcyc=50, drms=0.02' >> sander_qmmm_min.inp
  echo "  ntpr=10, ibelly=1, bellymask=\" ${NEW_QM_CMPLX_MASK_opt}, \" " >> sander_qmmm_min.inp
  echo '  ntb=0, ntf=1, ntc=1,' >> sander_qmmm_min.inp
  echo '  cut=999., ' >> sander_qmmm_min.inp
  echo '  ifqnt=1, ' >> sander_qmmm_min.inp
  echo ' &end' >> sander_qmmm_min.inp
  echo ' &qmmm' >> sander_qmmm_min.inp
  echo "    qmmask=\" ${NEW_QM_CMPLX_MASK_opt} \"," >> sander_qmmm_min.inp
  echo '    qmcut=999.0,' >> sander_qmmm_min.inp
  echo '    qm_ewald=0,' >> sander_qmmm_min.inp
  echo "    qm_theory=\"${QM_METHOD}\"," >> sander_qmmm_min.inp
  echo '    writepdb=1, ' >> sander_qmmm_min.inp
  echo "    qmcharge=${QM_CMPLX_CHARGE}, " >> sander_qmmm_min.inp
  echo '    adjust_q=0, ' >> sander_qmmm_min.inp
  echo '    dftb_disper=0, ' >> sander_qmmm_min.inp
  echo '    dftb_maxiter=100, ' >> sander_qmmm_min.inp
  echo ' &end' >> sander_qmmm_min.inp
  if [ -e $WORKDIR/tc.info ] && [ $QM_TC_RELAX == "YES" ] 
  then 
      cat $WORKDIR/tc.info >> sander_qmmm_min.inp 
  elif [ -e $WORKDIR/qm.info ] 
  then
      cat $WORKDIR/qm.info >> sander_qmmm_min.inp 
  fi

# SANDER input for QM/MM-GBSA  single-point calculations 
  echo 'single point' > sander_qmmm.inp
  echo ' &cntrl' >> sander_qmmm.inp
  echo '  imin=1, maxcyc=0,' >> sander_qmmm.inp
  echo '  ntb=0, ntf=1, ntc=1,' >> sander_qmmm.inp
  if [ ${QM_METHOD} == "DFTB3" ]
  then
     echo '  igb=1, gbsa=1 ' >> sander_qmmm.inp
  else
     echo '  igb=0, ' >> sander_qmmm.inp
  fi
  echo '  cut=999., ' >> sander_qmmm.inp
  echo '  ifqnt=1, ' >> sander_qmmm.inp
  echo ' &end' >> sander_qmmm.inp
  echo ' &qmmm' >> sander_qmmm.inp
  echo '    qmmask=" DUMMY_MASK ",' >> sander_qmmm.inp
  echo '    qmcut=999.0,' >> sander_qmmm.inp
  echo '    qm_ewald=0,' >> sander_qmmm.inp
  echo "    qm_theory=\"${QM_METHOD}\"," >> sander_qmmm.inp
  echo '    writepdb=1, ' >> sander_qmmm.inp
  echo '    printcharges=1, ' >> sander_qmmm.inp
  echo '    qmcharge= DUMMY_CHARGE , ' >> sander_qmmm.inp
  echo '    adjust_q=0, ' >> sander_qmmm.inp
  echo '    dftb_disper=0, ' >> sander_qmmm.inp
  echo '    dftb_maxiter=100, ' >> sander_qmmm.inp
  echo '    itrmax=100, ' >> sander_qmmm.inp
  echo '    pseudo_diag=0, ' >> sander_qmmm.inp
  echo ' &end' >> sander_qmmm.inp
  if [ -e $WORKDIR/qm.info ]; then cat $WORKDIR/qm.info >> sander_qmmm.inp; fi 

if [ "$NFRAG" -gt 1  ]
then

  for ((ifrag=1;ifrag<=NFRAG;ifrag++))
  do 
     QM_MASK=${NEW_QM_FRAG_MASK["$ifrag"]} 
     QM_CHARGE=${QM_CHARGE_FRAG["$ifrag"]} 
     sed "s/DUMMY_MASK/${QM_MASK}/" sander_qmmm.inp >sander_qmmm_frag_${ifrag}.inp 
     sed -i 's/DUMMY_MASK/\&/' sander_qmmm_frag_${ifrag}.inp
     sed -i "s/DUMMY_CHARGE/${QM_CHARGE}/" sander_qmmm_frag_${ifrag}.inp
  done 

fi

  sed -i "s/DUMMY_MASK/${NEW_QM_CMPLX_MASK_sp}/" sander_qmmm.inp
  sed -i 's/DUMMY_MASK/\&/' sander_qmmm.inp
  sed -i "s/DUMMY_CHARGE/${QM_CMPLX_CHARGE}/" sander_qmmm.inp

# Octave script for fixing Mulliken charges
  echo "q = load('temp.q');"  > fix_q_DUMMY.m
  echo 'n = length(q);  '  >> fix_q_DUMMY.m
  echo 'nqm = n - DUMMY ; '  >> fix_q_DUMMY.m
  echo 'qtot=sum(q);  '  >> fix_q_DUMMY.m
  echo 'qfix= ( qtot - sum (q(1:nqm)) ) / nqm ;  '  >> fix_q_DUMMY.m
  echo 'q = q + qfix * ones( n,1 ); '  >> fix_q_DUMMY.m
  echo "fid=fopen('temp.q','w'); "  >> fix_q_DUMMY.m
  echo 'for i= [1 : nqm ]  '  >> fix_q_DUMMY.m
  echo " fprintf(fid,' %15.6f \n',q(i)); "  >> fix_q_DUMMY.m
  echo 'end '  >> fix_q_DUMMY.m
  echo 'fclose(fid); '  >> fix_q_DUMMY.m
  echo 'quit '  >> fix_q_DUMMY.m

fi
###################################

# Preparing CRD files
$PDBCRD  < cmplxwat.pdb > cmplxwat.crd

# IF requested all the structures are rotated first to a common reference
if [ -e "$REFPDB" ]
then

  if [ ! -e ref.pdb ] 
  then
     cp $REFPDB ref.pdb 
     grep 'ATOM  ' ref.pdb | grep -v  'WAT\|HOH' | grep -v 'Na+' | grep -v 'Cl-' > temp.pdb_ref; mv temp.pdb_ref ref.pdb
  fi 

$CPPTRAJ <<EOF
parm       cmplxwat.top 
trajin     cmplxwat.crd  
trajout    cmplxwat.pdb_rotated  pdb   dumpq  include_ep
parm       cmplx.top 
reference  ref.pdb parm cmplx.top 
rmsd       ${REFMASK} reference 
go
EOF

  mv cmplxwat.pdb_rotated cmplxwat.pdb
fi


#
# For QMMM calculations, the QM region is first minimized 
# also we have to check carefully if SCF coonvergence is achieved or not.
#
if  [ "$QM_CMPLX_MASK" != "" ]            
then 

   echo 'Doing QMMM relaxation' 
   if [ ${QM_METHOD} == "DFTB3" ]
   then 
      $SANDER -O -i sander_mm_min.inp  -p cmplxwat.top -c cmplxwat.crd -o mm_relax.out -r temp.rst
      mv temp.rst cmplxwat.crd 
      $SANDER -O -i sander_scftest.inp  -p cmplxwat.top -c cmplxwat.crd -o scftest.out
      icheck=$(grep -c 'QMMM SCC-DFTB: Convergence could not be achieved' scftest.out)
      if [ "$icheck" -eq "0" ]
      then
      $SANDER -O -i sander_qmmm_min.inp  -p cmplxwat.top -c cmplxwat.crd -o qmmm_relax.out -r cmplxwat.rst 
      $CPPTRAJ cmplxwat.top<<EOF
trajin cmplxwat.rst
trajout cmplxwat.pdb_qmmm pdb dumpq  include_ep
go
EOF
      else
        mv scftest.out  $WORKDIR/${i/pdb/scftest} 
        continue 
      fi
   else
      if [ $QM_TC_RELAX == "YES" ]
      then 
          echo $QM_TC_LEVEL | sed 's/;/\n/g' > tc_job.tpl
      elif [  $QM_ORCA_RELAX == "YES" ]
      then
          echo $QM_ORCA_RELAX_LEVEL | sed 's/;/\n! /g' > orc_job.tpl 
          echo "%pal nprocs $NPROCS_ORCA end" >> orc_job.tpl
      else 
          echo $QM_ORCA_LEVEL | sed 's/;/\n! /g' > orc_job.tpl
          echo "%pal nprocs $NPROCS_ORCA end" >> orc_job.tpl
      fi
      $SANDER -O -i sander_qmmm_min.inp  -p cmplxwat.top -c cmplxwat.crd -o qmmm_relax.out -r cmplxwat.rst 
      $CPPTRAJ cmplxwat.top<<EOF
trajin cmplxwat.rst
trajout cmplxwat.pdb_qmmm pdb dumpq include_ep
go
EOF
     rm -r -f tc_job* orc_job*
   fi

   mv qmmm_relax.out  ${i/pdb/out_relax_qmmm}
   mv cmplxwat.rst cmplxwat.crd 
   mv cmplxwat.pdb_qmmm cmplxwat.pdb

fi

if [ "$N_SELECTED_WATERS" -gt "0"  ]
then

$CPPTRAJ cmplxwat.top <<EOF
trajin cmplxwat.crd
strip ":WAT & !${SELECTED_WATER}"
trajout cmplx.pdb pdb dumpq include_ep
go
EOF

$CPPTRAJ cmplxwat.top <<EOF
trajin cmplxwat.crd
strip "!:WAT | ${SELECTED_WATER}"
trajout wat.pdb pdb dumpq include_ep
go
EOF

else

grep -v 'WAT\|HOH' cmplxwat.pdb > cmplx.pdb
grep    'WAT\|HOH' cmplxwat.pdb > wat.pdb

fi


$PDBCRD  < cmplx.pdb > cmplx.crd
$PDBCRD  < wat.pdb  > wat.crd

if [ "$SKIPCMPLX" != "YES" ]
then

# Running the surface calculations 
$CPPTRAJ cmplx.top <<EOF
trajin cmplx.crd 
molsurf probe 1.4 out temp.AREA
go
EOF

AREA_CMPLX=$(tail -1 temp.AREA | awk '{print $2}' )
rm -f temp.AREA

# Using MSMS to make other CAVITY estimations (No Water or Na+ are considered) 
# GCAV program estimates cavitation using various approx: here we select only the C-SPT one
if [ "$EXCL_SOLV_SURFCAV" == "YES" ]; then grep -v 'WAT\| INA' cmplx.pdb > temp.pdb ; else cp cmplx.pdb temp.pdb ;fi 
awk '{printf(" %10.3f  %10.3f  %10.3f  %10.3f \n",$6,$7,$8,$10)}' temp.pdb | grep -v '  0.000 ' > temp.xyzr
nspe=$(cat temp.xyzr | wc -l)
$MSMS  -density 20.0 -probe_radius  1.4  -if temp.xyzr  -af temp.area  > temp.msms
VSES_NUM_CMPLX=$(grep -a2 "NUMERICAL VOLUMES AND AREA" temp.msms | tail -1 | awk '{print $3}')
ASES_NUM_CMPLX=$(grep -a2 "NUMERICAL VOLUMES AND AREA" temp.msms | tail -1 | awk '{print $4}')
ASES_ANAL_CMPLX=$(grep -a2 "ANALYTICAL SURFACE AREA" temp.msms | tail -1 | awk '{print $6 }' )

echo $nspe > temp.spe
echo "$VSES_NUM_CMPLX $ASES_NUM_CMPLX" >> temp.spe
echo "$ASES_ANAL_CMPLX" >> temp.spe
sed -s '1,1d' temp.area  | awk '{print $2}' >> temp.spe
awk '{print $4}' temp.xyzr >> temp.spe

declare -a gcav_data=""
# SPT-S   SPT-V   C-SPT   G_GRI   G_HOF   RV    RS   SES   VSES 
gcav_data=($($GCAV <temp.spe | awk '{printf(" %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f \n",$3,$5,$7,$9,$11,$13,$15,$17,$19)}'))
SPT_S_CMPLX=${gcav_data[0]} 
SPT_V_CMPLX=${gcav_data[1]} 
C_SPT_CMPLX=${gcav_data[2]}
rm -f  temp.msms temp.xyzr temp.area temp.pdb temp.spe

fi


# Obtaning the coordinates and molecular surface of the different fragments
if [ "$NFRAG" -gt 1 ]  && [ "$SKIPFRAG" != "YES" ]
then 

  declare -a AREA_FRAG=""
  declare -a ASES_NUM_FRAG=""
  declare -a VSES_NUM_FRAG=""
  declare -a ASES_ANAL_FRAG=""
  declare -a SPT_S_FRAG=""
  declare -a SPT_V_FRAG=""
  declare -a SPT_C_FRAG=""
  declare -a D3H4_FRAG=""

  for ((ifrag=1;ifrag<=NFRAG;ifrag++))
  do
    MASK=${NEW_FRAG_MASK["$ifrag"]}

   $CPPTRAJ cmplxwat.top <<EOF
trajin cmplxwat.crd
strip "!${MASK}"
trajout frag_${ifrag}.crd restart  
trajout frag_${ifrag}.pdb pdb dumpq  include_ep
molsurf probe 1.4 out temp.AREA
go
EOF

  AREA_FRAG["$ifrag"]=$(tail -1 temp.AREA | awk '{print $2}' )
  rm -f temp.AREA

# Using MSMS to make other CAVITY estimations (No Water or Na+ are considered) 
# GCAV program estimates cavitation using various approx: here we select only the C-SPT one
  if [ "$EXCL_SOLV_SURFCAV" == "YES" ]; then grep -v 'WAT\| INA' frag_${ifrag}.pdb > temp.pdb ; else cp frag_${ifrag}.pdb temp.pdb ;fi 
  awk '{printf(" %10.3f  %10.3f  %10.3f  %10.3f \n",$6,$7,$8,$10)}' temp.pdb | grep -v '  0.000 ' > temp.xyzr
  nspe=$(cat temp.xyzr | wc -l)
  $MSMS  -density 20.0 -probe_radius  1.4  -if temp.xyzr  -af temp.area  > temp.msms
  echo $nspe > temp.spe
  VSES_NUM_FRAG["$ifrag"]=$(grep -a2 "NUMERICAL VOLUMES AND AREA" temp.msms | tail -1 | awk '{print $3}')
  ASES_NUM_FRAG["$ifrag"]=$(grep -a2 "NUMERICAL VOLUMES AND AREA" temp.msms | tail -1 | awk '{print $4}')
  ASES_ANAL_FRAG["$ifrag"]=$(grep -a2 "ANALYTICAL SURFACE AREA" temp.msms | tail -1 | awk '{print $6 }' )

  echo $nspe > temp.spe
  echo "${VSES_NUM_FRAG["$ifrag"]}  ${ASES_NUM_FRAG["$ifrag"]} " >> temp.spe
  echo "${ASES_ANAL_FRAG["$ifrag"]} " >> temp.spe
  sed -s '1,1d' temp.area  | awk '{print $2}' >> temp.spe
  awk '{print $4}' temp.xyzr >> temp.spe

  # SPT-S   SPT-V   C-SPT   G_GRI   G_HOF   RV    RS   SES   VSES 
  declare -a gcav_data=""
  gcav_data=($($GCAV <temp.spe | awk '{printf(" %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f \n",$3,$5,$7,$9,$11,$13,$15,$17,$19)}'))
  SPT_S_FRAG["$ifrag"]=${gcav_data[0]} 
  SPT_V_FRAG["$ifrag"]=${gcav_data[1]} 
  C_SPT_FRAG["$ifrag"]=${gcav_data[2]}
  rm -f  temp.msms temp.xyzr temp.area temp.pdb temp.spe

done

fi

#
# For each ligand we compute the ADCK DGint scoring
#

if [ "$ADCK" == "YES"  ]   &&  [ "$NFRAG" -gt  1 ]
then

for ((IFRAG=2;IFRAG<=NFRAG;IFRAG++))
do

  # Assuming so far that fragments do not contain Water/Counterions
  let "ISITE=$IFRAG-1"
  rm -f receptor.* ligand.* receptor_ligand.*

  cp frag_${IFRAG}.pdb ligand.pdb
  NWAT_PDBQT=$(grep -c 'O   WAT' ligand.pdb) 
  NINA_PDBQT=$(grep -c 'INA  INA' ligand.pdb) 
  if [ $NWAT_PDBQT -gt 0 ]  || [ $NINA_PDBQT -gt 0 ] 
  then
      grep -v  'WAT\| INA ' ligand.pdb > ligand_solute.pdb
      grep ' INA ' ligand.pdb > ligand_INA.pdb
      grep ' WAT ' ligand.pdb > ligand_WAT.pdb
      cat ligand_solute.pdb ligand_INA.pdb ligand_WAT.pdb > ligand.pdb
      $REORDER < ligand.pdb > tmp; mv  tmp ligand.pdb
      cat LIG_template_${ISITE}.pdbqt  > LIG_INAWAT_template_${ISITE}.pdbqt
      for ((imol=1;imol<=NINA_PDBQT;imol++))
      do
         cat ${PDBQT_NA} >> LIG_INAWAT_template_${ISITE}.pdbqt
      done
      for ((imol=1;imol<=NWAT_PDBQT;imol++))
      do
         cat ${PDBQT_WAT} >> LIG_INAWAT_template_${ISITE}.pdbqt
      done
      $REORDER < LIG_INAWAT_template_${ISITE}.pdbqt > tmp; mv tmp LIG_INAWAT_template_${ISITE}.pdbqt
      $TOOLS/merge_pdbqt LIG_INAWAT_template_${ISITE}.pdbqt ligand.pdb ligand_ATOM.pdbqt
  else
      $TOOLS/merge_pdbqt LIG_template_${ISITE}.pdbqt  ligand.pdb  ligand_ATOM.pdbqt
  fi

  cp frag_1.pdb  receptor.pdb
  for ((JFRAG=2;JFRAG<=NFRAG;JFRAG++))
  do
     if [ "$JFRAG" -ne "$IFRAG" ]
     then
         cat frag_${JFRAG}.pdb >> receptor.pdb
     fi
  done
  $REORDER < receptor.pdb > tmp; mv  tmp receptor.pdb 
  NWAT_PDBQT=$(grep -c 'O   WAT' receptor.pdb) 
  NINA_PDBQT=$(grep -c 'INA  INA' receptor.pdb) 
  if [ $NWAT_PDBQT -gt 0 ]  || [ $NINA_PDBQT -gt 0 ] 
  then
      grep -v  'WAT\| INA ' receptor.pdb > receptor_solute.pdb
      grep ' INA ' receptor.pdb > receptor_INA.pdb
      grep ' WAT ' receptor.pdb > receptor_WAT.pdb
      cat receptor_solute.pdb receptor_INA.pdb receptor_WAT.pdb > receptor.pdb
      $REORDER < receptor.pdb > tmp; mv  tmp receptor.pdb
      cat REC_template_${ISITE}.pdbqt  > REC_INAWAT_template_${ISITE}.pdbqt
      for ((imol=1;imol<=NINA_PDBQT;imol++))
      do
         cat ${PDBQT_NA} >> REC_INAWAT_template_${ISITE}.pdbqt
      done
      for ((imol=1;imol<=NWAT_PDBQT;imol++))
      do
         cat ${PDBQT_WAT} >> REC_INAWAT_template_${ISITE}.pdbqt
      done
      $REORDER < REC_INAWAT_template_${ISITE}.pdbqt > tmp; mv tmp REC_INAWAT_template_${ISITE}.pdbqt
      $TOOLS/merge_pdbqt REC_INAWAT_template_${ISITE}.pdbqt receptor.pdb receptor.pdbqt
   else
      $TOOLS/merge_pdbqt REC_template_${ISITE}.pdbqt receptor.pdb receptor.pdbqt
   fi

  $TOOLS/center_geom -noatm -i ligand.pdb -o ligand.size
  CEN_LIG=$(grep 'COM  =' ligand.size |  awk '{printf("%f %f %f\n",$4,$5,$6)}')
  DIM_LIG=$(grep 'XYZ DIM' ligand.size |  awk '{printf("%f %f %f\n",$5,$6,$7)}')
  SIZE=$(echo $DIM_LIG $GRID | awk '{ix=2.0*$1/$4; iy=2.0*$2/$4; iz=2.0*$3/$4; printf("%i,%i,%i \n",ix,iy,iz)}')
  echo "LIG SIZE=$SIZE"

  echo 'ROOT' >  ligand.pdbqt
  grep 'ATOM '  ligand_ATOM.pdbqt >> ligand.pdbqt
  echo 'ENDROOT' >> ligand.pdbqt
  echo 'TORSDOF 0' >> ligand.pdbqt
  rm -f ligand_ATOM.pdbqt

 # Preparing input for AUTOGRID 
  echo "parameter_file  ${APTAMD}/SOFT/mgltools_x86_64Linux2_1.5.7/MGLToolsPckgs/AutoDockTools/AD4_parameters.dat" > receptor.gpf
  echo " $PYTHONSH $AUTODOCKTOOLS/Utilities24/prepare_gpf4.py -l ligand.pdbqt -r receptor.pdbqt  -o tmp_receptor.gpf   -p npts=${SIZE} -p spacing="${GRID}" -p gridcenter="0.,0.,0.""
  $PYTHONSH $AUTODOCKTOOLS/Utilities24/prepare_gpf4.py -l ligand.pdbqt -r receptor.pdbqt  -o tmp_receptor.gpf \
-p npts=${SIZE} -p spacing="${GRID}" -p gridcenter="0.,0.,0."
  grep -v gridcenter tmp_receptor.gpf >> receptor.gpf
  ed receptor.gpf <<EOF
/map receptor
i
gridcenter ${CEN_LIG}           # xyz-coordinates or auto
.
wq
EOF
  rm -f tmp_receptor.gpf

  # Preparing input for AUTODOCK
  echo "parameter_file  ${APTAMD}/SOFT/mgltools_x86_64Linux2_1.5.7/MGLToolsPckgs/AutoDockTools/AD4_parameters.dat" > receptor_ligand.dpf
  $PYTHONSH $AUTODOCKTOOLS/Utilities24/prepare_dpf4.py -l ligand.pdbqt -r receptor.pdbqt -o tmp_receptor_ligand.dpf -p ga_run="1"
  sed -n '1,/move/p' tmp_receptor_ligand.dpf >> receptor_ligand.dpf
  echo 'epdb' >> receptor_ligand.dpf
  rm -f tmp_receptor_ligand.dpf

#  Running Autodock programs 
  $APTAMD/SOFT/autogrid4 -p receptor.gpf -l receptor.glg;    \
  $APTAMD/SOFT/autodock4 -p receptor_ligand.dpf -l receptor_ligand.dlg

  energy=$(grep "Final Intermolecular Energy" receptor_ligand.dlg | awk '{print $8}' )
# echo "${i/.pdb/} $energy" >> $WORKDIR/E_INT_ADCK_${ISITE}.dat 
  sed  '1,/Intermolecular Energy Analysis/d' receptor_ligand.dlg  | sed '/Estimated Free Energy of Binding/,$d'  > $WORKDIR/${i/pdb/dlg${ISITE}}
  
done 

# No more things to do in the  BIG loop
if [ "$ADCK_ONLY" == "YES" ]; then continue ;fi

fi

# IGB=1 ---> IGB=6 fix for FF containing EP (extra-point) parameters
NEP=$(sed '1,/AMBER_ATOM_TYPE/d' cmplx.top | sed '/FLAG/,$d' | grep -c 'EP') 
IFIRST_NEP=1
if [ $NEP -gt 0 ]
then 
   if [ $IFIRST_NEP -eq 1 ]
   then
      echo "WARNING: cmplx.top contains EP (extra-point) atom-type"
      echo "WARNING: igb=1 cacls are deactivated"
      IFIRST_NEP=0
   fi
   sed -i 's/igb=1/igb=6/' *.inp 
fi

# Dealing with QMMM calcs is a totally different bussiness than MM 
if  [ "$QM_CMPLX_MASK" != "" ]            
then 
  
  if [ "$SKIPCMPLX" != "YES" ]
  then

  $SANDER  -O -i sander.inp -o ${i/pdb/out1} -p cmplxwat.top -c cmplxwat.crd
  $SANDER  -O -i sander.inp -o ${i/pdb/out2} -p wat.top -c wat.crd  

  if [ $QM_ORCA == "YES" ]; then echo $QM_ORCA_LEVEL | sed 's/;/\n! /g' > orc_job.tpl; echo "%pal nprocs $NPROCS_ORCA end" >> orc_job.tpl ; fi 
  $SANDER  -O -i sander_qmmm.inp -p cmplx.top -c cmplx.crd  -o ${i/pdb/out3}

  if [ ${QM_ORCA} != "YES" ]
  then 

  rm -f cmplx_TEMP.top cmplx.pdbq
  rm -f temp.qmmm temp.q
  $AMBMASK -p cmplx.top -c cmplx.crd -find   "${NEW_QM_CMPLX_MASK_sp}"  | grep 'ATOM  ' > temp.qmmm
  nlink=$(grep 'QMMM:  nlink =\|QMMM: nlink =' ${i/pdb/out3} | awk '{print $4}')
  sed '1,/Atom    Element       Mulliken Charge/d'  ${i/pdb/out3} | sed '/Total Mulliken Charge =/,$d' | awk '{print $3}' > temp.q
  sed "s/DUMMY/${nlink}/" fix_q_DUMMY.m > fix_q.m
  $OCTAVE -q fix_q.m
  paste  temp.qmmm temp.q > cmplx.pdbq 
  $FIXPQRTOP -pqr cmplx.pdbq -topin cmplx.top -topout cmplx_TEMP.top > mlog

  else

  rm -f cmplx_TEMP.top cmplx.pdbq
  rm -f temp.qmmm temp.q temp_orca*

  cp orc_job.gbw     temp_orca.gbw
  mv old.orc_job.dat temp_orca.dat
  mkdir temp_orca_chelpg; cd temp_orca_chelpg; $ORCA/orca_chelpg ../temp_orca.gbw  > ../temp_orca.chelpg; cd ../; rm -r -f temp_orca_chelpg
  rm -f orc_*tmp inpfile.xyz ptchrg.xyz
  rm -f orc_job.dat orc_job.inp orc_job.prop
  mv orc_job.gbw cmplx.gbw

  $AMBMASK -p cmplx.top -c cmplx.crd -find   "${QM_PROT_MASK}"  | grep 'ATOM  ' > temp.qmmm
  nlink=$(grep 'QMMM:  nlink =\|QMMM: nlink =' ${i/pdb/out3} | awk '{print $4}')
  sed  '1,/CHELPG Charges/d'   temp_orca.chelpg | sed '/Total charge/,$d' | sed '1,1 d' | sed '$,$d' | awk '{print $4}' > temp.q
  sed "s/DUMMY/${nlink}/" fix_q_DUMMY.m > fix_q.m
  $OCTAVE -q fix_q.m
  paste  temp.qmmm temp.q > cmplx.pdbq
  $FIXPQRTOP -pqr cmplx.pdbq -topin cmplx.top -topout cmplx_TEMP.top > mlog

  fi 

  if [ ${QM_ADD_D3H4} == "YES" ]
  then

  grep 'QMMM\|qmcharge' ${i/pdb/out3}  > temp.out   
  qm_charge=$(grep '  qmgb =' temp.out | awk '{print $6}')
  cat temp.out | sed '1,/QM_NO.   MM_NO.  ATOM/d' | sed '/Citation for AMBER QMMM Run:/,$d' | grep 'QMMM:' > temp.xyz_qmmm
  sed -i 's/        \*/  LINK  /' temp.xyz_qmmm
  nat=$(cat temp.xyz_qmmm | wc -l)
  echo "$nat" > temp.xyz
  echo ' ' >> temp.xyz
  awk '{printf(" %s %12.5f %12.5f %12.5f \n",$4,$5,$6,$7)}' temp.xyz_qmmm  >> temp.xyz
  declare -a ecuby=""
  ecuby=($($CUBY4 -v minimal input_cuby4.yaml)) 
  e_1=${ecuby[0]}
  e_2=${ecuby[1]}
  D3H4_CMPLX=$(echo "$e_1 $e_2" | awk '{e_diff=$2-$1; print e_diff}') 
  rm -f temp.xyz_qmmm temp.out temp.xyz 

  fi


  # PB calc
  if [ "$PBNL" == "YES"  ]
  then 
    $PBSA -O -i pbsa_e80.inp  -p cmplx_TEMP.top -c cmplx.crd
    cat mdout >> ${i/pdb/out3}
  else
    $PBSA -O -i pbsa_lin.inp  -p cmplx_TEMP.top -c cmplx.crd
    cat mdout >> ${i/pdb/out3}
  fi 
  cat cmplx.pdbq >> ${i/pdb/out3}
  echo '==================================' >>  ${i/pdb/out3}
  if [ ${QM_ADD_D3H4} == "YES" ]
  then
      echo "D3H4 correction = $D3H4_CMPLX" >>  ${i/pdb/out3} 
      echo '==================================' >>  ${i/pdb/out3}
  fi
  echo 'Surface calculations' >>  ${i/pdb/out3} 
  echo "AREA_MOLSURF=  $AREA_CMPLX  " >>  ${i/pdb/out3}
  echo "SES_NUM=  $ASES_NUM_CMPLX  " >>  ${i/pdb/out3}
  echo "SES_ANAL=  $ASES_ANAL_CMPLX  " >>  ${i/pdb/out3}
  echo "VSES_NUM=  $VSES_NUM_CMPLX  " >>  ${i/pdb/out3}
  echo "CAVITATION(SPT_S)=  $SPT_S_CMPLX  " >>  ${i/pdb/out3}
  echo "CAVITATION(SPT_V)=  $SPT_V_CMPLX  " >>  ${i/pdb/out3}
  echo "CAVITATION(C-SPT)=  $C_SPT_CMPLX  " >>  ${i/pdb/out3}
  echo '==================================' >>  ${i/pdb/out3}

  fi

  if [ "$NFRAG" -gt 1 ]  &&  [ $SKIPFRAG != "YES" ] 
  then

  for ((ifrag=1;ifrag<=NFRAG;ifrag++))
  do

  QM_MASK=${NEW_QM_FRAG_MASK["$ifrag"]} 
  AREA=${AREA_FRAG["$ifrag"]}

  let "iout = $ifrag + 3 "
  ext=out${iout} 

  if [ "${QM_MASK}" == "" ]
  then 
    $SANDER  -O -i sander_mmgb.inp -o ${i/pdb/}${ext} -p frag_${ifrag}.top -c frag_${ifrag}.crd
    cp frag_${ifrag}.top  frag_${ifrag}_TEMP.top
  else
  #QMMM calc

    if [ $QM_ORCA == "YES" ]
    then 
        echo $QM_ORCA_LEVEL | sed 's/;/\n! /g' > orc_job.tpl; echo "%pal nprocs $NPROCS_ORCA end" >> orc_job.tpl 
    fi 
    $SANDER  -O -i sander_qmmm_frag_${ifrag}.inp -o ${i/pdb/}${ext} -p frag_${ifrag}.top -c frag_${ifrag}.crd

    if [ ${QM_ORCA} != "YES" ]
    then 

    rm -f frag_${ifrag}_TEMP.top frag_${ifrag}.pdbq
    $AMBMASK -p frag_${ifrag}.top -c frag_${ifrag}.crd -find "${QM_MASK}"  | grep 'ATOM  ' > temp.qmmm
    nlink=$(grep 'QMMM:  nlink =\|QMMM: nlink =' ${i/pdb/}${ext} | awk '{print $4}')
    sed '1,/Atom    Element       Mulliken Charge/d'  ${i/pdb/}${ext} | sed '/Total Mulliken Charge =/,$d' | awk '{print $3}' > temp.q
    sed "s/DUMMY/${nlink}/" fix_q_DUMMY.m > fix_q.m
    $OCTAVE -q fix_q.m
    paste  temp.qmmm temp.q > frag_${ifrag}.pdbq 
    $FIXPQRTOP -pqr frag_${ifrag}.pdbq -topin frag_${ifrag}.top -topout frag_${ifrag}_TEMP.top > mlog
    cat frag_${ifrag}.pdbq >> ${i/pdb/}${ext}

    else

    rm -f frag_${ifrag}_TEMP.top frag_${ifrag}.pdbq
    rm -f temp.qmmm temp.q temp_orca*

    cp orc_job.gbw     temp_orca.gbw
    mv old.orc_job.dat temp_orca.dat
    mkdir temp_orca_chelpg; cd temp_orca_chelpg; $ORCA/orca_chelpg ../temp_orca.gbw  > ../temp_orca.chelpg; cd ../; rm -r -f temp_orca_chelpg
    rm -f orc_*tmp inpfile.xyz ptchrg.xyz
    rm -f orc_job.dat orc_job.inp orc_job.prop
    mv orc_job.gbw cmplx.gbw

    $AMBMASK -p frag_${ifrag}.top -c frag_${ifrag}.crd -find "${QM_MASK}"  | grep 'ATOM  ' > temp.qmmm
    nlink=$(grep 'QMMM:  nlink =\|QMMM: nlink =' ${i/pdb/}${ext} | awk '{print $4}')
    sed  '1,/CHELPG Charges/d'   temp_orca.chelpg | sed '/Total charge/,$d' | sed '1,1 d' | sed '$,$d' | awk '{print $4}' > temp.q
    sed "s/DUMMY/${nlink}/" fix_q_DUMMY.m > fix_q.m
    $OCTAVE -q fix_q.m
    paste  temp.qmmm temp.q > frag_${ifrag}.pdbq 
    $FIXPQRTOP -pqr frag_${ifrag}.pdbq -topin frag_${ifrag}.top -topout frag_${ifrag}_TEMP.top > mlog
    cat frag_${ifrag}.pdbq >> ${i/pdb/}${ext}

    fi
    
  fi 

  if [ ${QM_ADD_D3H4} == "YES" ]
  then

  grep 'QMMM\|qmcharge'  ${i/pdb/}${ext} temp.out   
  qm_charge=$(grep '  qmgb =' temp.out | awk '{print $6}')
  cat temp.out | sed '1,/QM_NO.   MM_NO.  ATOM/d' | sed '/Citation for AMBER QMMM Run:/,$d' | grep 'QMMM:' > temp.xyz_qmmm
  sed -i 's/        \*/  LINK  /' temp.xyz_qmmm
  nat=$(cat temp.xyz_qmmm | wc -l)
  echo "$nat" > temp.xyz
  echo ' ' >> temp.xyz
  awk '{printf(" %s %12.5f %12.5f %12.5f \n",$4,$5,$6,$7)}' temp.xyz_qmmm  >> temp.xyz
  sed  "s/DUMMY_CHARGE/$qm_charge/" template_d3h4.yaml >  temp.yaml
  declare -a ecuby=""
  ecuby=($($CUBY4 -v minimal temp.yaml)) 
  e_1=${ecuby[0]}
  e_2=${ecuby[1]}
  D3H4_FRAG["$ifrag"]=$(echo "$e_1 $e_2" | awk '{e_diff=$2-$1; print e_diff}') 
  rm -f temp.xyz_qmmm temp.out temp.xyz temp.yaml 

  fi

  # PB calc
  if [ "$PBNL" == "YES"  ]
  then 
    $PBSA -O -i pbsa_e80.inp  -p frag_${ifrag}_TEMP.top -c frag_${ifrag}.crd
    cat mdout >> ${i/pdb/}${ext}
  else
    $PBSA -O -i pbsa_lin.inp  -p frag_${ifrag}_TEMP.top -c frag_${ifrag}.crd
    cat mdout >> ${i/pdb/}${ext}
  fi 
  echo '==================================' >>  ${i/pdb/}${ext}
  if [ ${QM_ADD_D3H4} == "YES" ]
  then
      echo "D3H4 correction = $D3H4_CMPLX" >>  ${i/pdb/}${ext}
      echo '==================================' >> ${i/pdb/}${ext}
  fi
  echo 'Surface calculations' >>  ${i/pdb/}${ext}
  echo "AREA_MOLSURF=  ${AREA_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "SES_NUM=  ${ASES_NUM_FRAG["$ifrag"]} " >>  ${i/pdb/}${ext}
  echo "SES_ANAL=  ${ASES_ANAL_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "VSES_NUM=  ${VSES_NUM_FRAG["$ifrag"]} " >>  ${i/pdb/}${ext}
  echo "CAVITATION(SPT_S)=  ${SPT_S_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "CAVITATION(SPT_V)=  ${SPT_V_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "CAVITATION(C-SPT)=  ${C_SPT_FRAG["$ifrag"]} " >>  ${i/pdb/}${ext}
  echo '==================================' >>  ${i/pdb/}${ext}

  done 
 
  fi
   
else 
  #  MMPBSA calcs.....

  if [ "$SKIPCMPLX" != "YES" ]
  then

  # Running the single-point calculations. 

  # MM calc
  $SANDER  -O -i sander.inp -o ${i/pdb/out1} -p cmplxwat.top -c cmplxwat.crd
  $SANDER  -O -i sander.inp -o ${i/pdb/out2} -p wat.top -c wat.crd  
  $SANDER  -O -i sander_mmgb.inp -o ${i/pdb/out3} -p cmplx.top -c cmplx.crd

  if [ "$RISM" == "YES" ] 
  then 

     # 3D-RISM calc
     $SANDER  -O -i sander_mmrism.inp  -p cmplx.top -c cmplx.crd -xvv solvent.xvv 
     cat mdout >> ${i/pdb/out3}

  else

    # PB calc
    if [ "$PBNL" == "YES"  ]
    then 
      $PBSA -O -i pbsa_e80.inp  -p cmplx.top -c cmplx.crd
      cat mdout >> ${i/pdb/out3}
    else
      $PBSA -O -i pbsa_lin.inp  -p cmplx.top -c cmplx.crd
      cat mdout >> ${i/pdb/out3}
    fi 

  fi

  echo '==================================' >>  ${i/pdb/out3}
  echo 'Surface calculations' >>  ${i/pdb/out3}
  echo 'NO WAT/INA considered' >>  ${i/pdb/out3}
  echo "AREA_MOLSURF=  $AREA_CMPLX  " >>  ${i/pdb/out3}
  echo "SES_NUM=  $ASES_NUM_CMPLX  " >>  ${i/pdb/out3}
  echo "SES_ANAL=  $ASES_ANAL_CMPLX  " >>  ${i/pdb/out3}
  echo "VSES_NUM=  $VSES_NUM_CMPLX  " >>  ${i/pdb/out3}
  echo "CAVITATION(SPT_S)=  $SPT_S_CMPLX  " >>  ${i/pdb/out3}
  echo "CAVITATION(SPT_V)=  $SPT_V_CMPLX  " >>  ${i/pdb/out3}
  echo "CAVITATION(C-SPT)=  $C_SPT_CMPLX  " >>  ${i/pdb/out3}
  echo '==================================' >>  ${i/pdb/out3}


  fi

  if [ "$NFRAG" -gt 1 ]   && [ "$SKIPFRAG" != "YES" ]
  then

    for ((ifrag=1;ifrag<=NFRAG;ifrag++))
    do

    AREA=${AREA_FRAG["$ifrag"]}

    let "iout = $ifrag + 3 "
    ext=out${iout}

    #MM calc
    $SANDER  -O -i sander_mmgb.inp -o ${i/pdb/}${ext} -p frag_${ifrag}.top -c frag_${ifrag}.crd

    if [ "$RISM" == "YES" ]
    then 

      #RISM calc
      $SANDER  -O -i sander_mmrism.inp -p frag_${ifrag}.top -c frag_${ifrag}.crd -xvv solvent.xvv 
      cat mdout >> ${i/pdb/}${ext}

    else

      #PB calc
      if [ "$PBNL" == "YES" ]
      then 
        $PBSA -O -i pbsa_e80.inp  -p frag_${ifrag}.top -c frag_${ifrag}.crd
        cat mdout >> ${i/pdb/}${ext}
      else 
        $PBSA -O -i pbsa_lin.inp  -p frag_${ifrag}.top -c frag_${ifrag}.crd
        cat mdout >> ${i/pdb/}${ext}
      fi

    fi

#Surface calculations
  echo '==================================' >>  ${i/pdb/}${ext}
  echo 'Surface calculations' >>  ${i/pdb/}${ext}
  echo "AREA_MOLSURF=  ${AREA_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "SES_NUM=  ${ASES_NUM_FRAG["$ifrag"]} " >>  ${i/pdb/}${ext}
  echo "SES_ANAL=  ${ASES_ANAL_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "VSES_NUM=  ${VSES_NUM_FRAG["$ifrag"]} " >>  ${i/pdb/}${ext}
  echo "CAVITATION(SPT_S)=  ${SPT_S_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "CAVITATION(SPT_V)=  ${SPT_V_FRAG["$ifrag"]}  " >>  ${i/pdb/}${ext}
  echo "CAVITATION(C-SPT)=  ${C_SPT_FRAG["$ifrag"]} " >>  ${i/pdb/}${ext}
  echo '==================================' >>  ${i/pdb/}${ext}

  done 

  fi
  

fi

#  Moving output files to working directory
mv ${i/pdb/out}*       $WORKDIR/
mv cmplx.pdb           $WORKDIR/${i/pdb/pdb3}
gzip -f $WORKDIR/${i/pdb/out}*  $WORKDIR/${i/pdb/pdb3} 

else 

  echo "Output files for ${i} are located in $WORKDIR."
  echo "Remove them if you wish to recompute this PDB snapshot ."

fi

done 
#=======================================================================================
 
#Cleaning up everything in the scratch directory
rm -r -f $TMPDIR 

