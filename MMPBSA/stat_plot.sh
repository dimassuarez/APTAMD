#!/bin/bash

if [ -z "$APTAMD" ]; then echo "APTAMD variable is not defined!" ; exit; fi
source $APTAMD/ENV/geuo_env.sh

export LANG="C" 
alias iconv='iconv -s'

# This script reads data in .dat files generated by data_parser.sh 
# and computes the average values, standard deviations and block error estimates.
#
# Data are first filtered so that rows with incomplete (i.e., " 0.000") fields are removed.
#
# Usage;
# 		 bash stat_plot.sh
# 
# The script reads all .dat files in the current directory.
# On output, the scripts prints out .med files containing all the statistical info
#
# If some data from a .dat file are removed, an equivalent .dat_filt file is also  printed
# what can be good for plotting purposes.
#

# Programs being used:
#
# G_ANALYZE implements the Hess' method of error estimation based on non-linear fitting
# (JCP 2002  Vol 116 pag 209)
#
G_ANALYZE="mpirun -np 1 /opt/gromacs/2023/bin/gmx_mpi analyze -ee -f "

# MEDIA_BSE the limiting value of the error estimate by  block averaging 
# (See Grossfield & Zuckerman, Annual Reports in Computational Chemistry, 2009, vol5, 23) 
MEDIA_BSE="$TOOLS/media_bse" 

# At least one of the two programs (G_ANALYZE or MEDIA_BSE) is needed

################################################################################3333
rm -f temp.*  *.dat_filt 

if [ "$G_ANALYZE" == ""  ] && [ "$MEDIA_BSE" == "" ] 
then
   echo 'G_ANALYZE and MEDIA_BSE executables are not available!'
   exit
fi
if [ "$G_ANALYZE" == "" ] 
then
   echo 'G_ANALYZE executable is not available!'
fi
if [ "$MEDIA_BSE" == ""  ] 
then
   echo 'MEDIA_BSE executable is not available!'
fi
if [ "$OUTLYER" ==  "" ]
then
    OUTLYER="0"
fi
if [ ! "$DO_STAT_PLOT" ]
then 
  DO_STAT_PLOT="0"
  echo "Do you want to create PLOTS for the .dat files (Y/N) ?"
  read YES              
  if [ "$YES" == "Y" ] || [ "$YES" == "y" ]
  then
     DO_STAT_PLOT="1" 
  fi 
fi

CONVERT=$(which convert | grep -v alias)
$CONVERT -version >& tmp
icheck=$(grep Version tmp | grep -c ImageMagick ) 
rm -f tmp
if [ $icheck -ne  1 ] &&  [ $DO_STAT_PLOT -eq 1 ] 
then 
    DO_STAT_PLOT=0
    echo "convert command (ImageMagick) is not available" 
    echo "DO_PLOT option is deactivated."
fi
# Suppress warning messages
CONVERT="${CONVERT} -quiet "

if [ ! "$DO_STAT_PERCEN" ]
then 
  DO_STAT_PERCEN="0"
  echo "Enter the percentage of DATA used for statistics:"
  echo "================================================:"
  echo "Examples:  "
  echo "  0 or null --> Use all data "
  echo " -33        --> Use the last third (33%)"
  echo " 50 or +50  --> Use the first half of data  "
  echo "Enter here the desired percentarge ... "
  read DO_STAT_PERCEN
fi

if [ "$DO_STAT_PERCEN" ==  "" ] 
then
    DO_STAT_PERCEN="0"
fi

if [ "$DO_STAT_PERCEN" -gt "100" ] 
then
   echo 'PERCENTAGE greater than 100' 
   exit
fi
if [ "$DO_STAT_PERCEN" -lt "-100" ] 
then
   echo 'PERCENTAGE greater than 100' 
   exit
fi

declare -a HEADERS=""

for file in $(ls *.dat) 
do
   rm -f temp.*
   icheck=$(head -1 $file | grep -c "# PREFIX"  )
   if [ $icheck -eq "0" ]
   then
     echo "$file not processed. Does not look MMPBGBSA or QMMMGBSA data file." 
   else
     prefix=${file%%.*}
     HEADERS=( $(grep '# PREFIX' $file  ) )
     grep -v '# ' $file >  temp.dat 
     NF=$(awk '{ print NF }' temp.dat | head -1) 
     NR=$(cat temp.dat |wc -l)
     grep -v ' 0.000 ' temp.dat | grep -v ' \-0.069 ' > temp.dat_filtered
     NR_filt=$(cat temp.dat_filtered |wc -l)
     echo " $file contains $NF fields with $NR original records. $NR_filt records after filtering lines with 0.000 values" 
#    Outlyer filtering
     if [ ${OUTLYER} == 1 ]
     then 

     awk '{$1=""; print $0}' temp.dat_filtered > temp.dat_filtered_numeric
     $OCTAVE --silent <<EOF
A=load('temp.dat_filtered_numeric');
[ndat, n]=size(A);
indx=diag(zeros(ndat)) ;
for i=[1:n]
   iqr15=iqr(A(:,i)) * 1.5;
   q=quantile(A(:,i)) ;
   q1=q(1);
   q3=q(3);
   for j=[1:ndat]
     if (  A(j,i) < q1 - iqr15 )   ||  ( A(j,i) > q3 + iqr15  )
        indx(j)=1 ;
     end
   end
end
fid=fopen('temp_outlyer.dat','w');
for j=[1:ndat]
   fprintf(fid,' outlyer=%i \n',indx(j));
end
fclose(fid);
exit
EOF
    paste temp.dat_filtered temp_outlyer.dat | grep -v 'outlyer=1' | sed 's/\t/ /g' | sed 's/outlyer=0//' > temp; mv temp temp.dat_filtered
    rm -f temp.dat_filtered_numeric temp_outlyer.dat
    NR_filt=$(cat temp.dat_filtered |wc -l)
    echo " $file contains $NF fields with $NR original records. $NR_filt records after filtering outlyers" 

    fi
#
     if [ "$DO_STAT_PERCEN" -gt 0 ] 
     then
       let  " NR_use =  ( $NR_filt *  $DO_STAT_PERCEN ) / 100  "  
       head -${NR_use} temp.dat_filtered > temp.dat_filtered_use
       mv temp.dat_filtered_use temp.dat_filtered
       NR_filt=$(cat temp.dat_filtered |wc -l)
     fi
     if [ "$DO_STAT_PERCEN" -lt 0 ] 
     then
       let  " NR_use =  ( $NR_filt *  ( - $DO_STAT_PERCEN )  ) / 100  "  
       tail -${NR_use} temp.dat_filtered > temp.dat_filtered_use
       mv temp.dat_filtered_use temp.dat_filtered
       NR_filt=$(cat temp.dat_filtered |wc -l)
     fi
     FMT=""

     nlines=$(cat temp.dat_filtered | wc -l) 
     rm -f temp.index
     for ((I=1; I<= nlines; I++))
     do 
        echo " $I " >> temp.index
     done
#    awk '{print $1}' temp.dat_filtered | sed 's/[^0-9]//g' > temp.index 

     for ((I=2; I <= NF; I++))
     do 
        awk "{print $"${I}" }" temp.dat_filtered > temp.col.xvg
#
        if [ "$G_ANALYZE" != "" ]
        then 
          $G_ANALYZE  temp.col.xvg >& temp.med 
          rm -f errest.xvg temp.media_bse
          MEAN["$I"]=$(grep 'SS1 ' temp.med | awk '{printf(" %12.3f \n",$2)}')
          SE["$I"]=$(grep 'SS1 ' temp.med | awk '{printf(" %12.3f \n",$4)}')
          BSE["$I"]=$(grep 'Set   1' temp.med | awk '{printf(" %12.3f \n",$4)}')
        fi 
#
        if [ "$MEDIA_BSE" != "" ]
        then 
          $MEDIA_BSE < temp.col.xvg > temp.media_bse
          MEAN["$I"]=$( grep 'MEDIA=' temp.media_bse | awk '{printf(" %12.3f \n",$2)}')
            SE["$I"]=$( grep 'ERROR STANDARD' temp.media_bse | awk '{printf(" %12.3f \n",$4)}')
           LBE["$I"]=$( grep 'LIMIT BLOCKED ' temp.media_bse | awk '{printf(" %12.3f \n",$5)}')
           MAX["$I"]=$( grep 'MAX=' temp.media_bse  | awk '{printf(" %12.3f \n",$2)}')
           MIN["$I"]=$( grep 'MIN=' temp.media_bse  | awk '{printf(" %12.3f \n",$4)}')
        fi
#
        if [ "$DO_STAT_PLOT" -eq "1" ]
        then 
           DUMMY_DAT=${prefix}_${I}            
           DUMMY_NAME=${HEADERS["$I"]}
           DUMMY_NAME=${DUMMY_NAME//_/ } 
           DUMMY_TITLE=$(echo "Mean=${MEAN["$I"]} SE=${SE["$I"]} LBE=${LBE["$I"]}")
           paste temp.index  temp.col.xvg > temp.dat.plot
           echo ' 0; ' > temp.m
           echo ' function ymed=ymed_curve(y,ninter) ' >> temp.m
           echo ' n=length(y); ' >> temp.m
           echo ' for i=[1:n] ' >> temp.m
           echo '   if  i > ninter && i < n-ninter ' >> temp.m
           echo '      ymed(i)=mean(y(i-ninter:i+ninter)); ' >> temp.m
           echo '   elseif i <= ninter ' >> temp.m
           echo '      ymed(i)=mean(y(1:i+ninter+(ninter-i))); ' >> temp.m
           echo '   elseif i >= n-ninter ' >> temp.m
           echo '    ymed(i)=mean(y(i-ninter:n)); ' >> temp.m
           echo '   end ' >> temp.m
           echo ' end ' >> temp.m
           echo ' end ' >> temp.m
           echo 'A=load("temp.dat.plot");' >>  temp.m
           echo '[imax jmax]=size(A);'>> temp.m
           echo 'ninter=round(imax/20)+1;' >> temp.m
           echo 'A_MED=ymed_curve(A(:,2),ninter);' >> temp.m
           echo 'clf();'>> temp.m
           echo 'h=figure(1);'>> temp.m
           echo 'plot (A(:,1),A(:,2),"-r",A(:,1),A_MED,"-y","linewidth",2.5)'>> temp.m 
           echo 'grid on;'>> temp.m 
           echo 'FN = findall(h,"-property","FontName");'>> temp.m 
           echo 'set(FN,"FontName","/usr/share/fonts/dejavu/DejaVuSerifCondensed.ttf");'>> temp.m 
           echo 'FS = findall(h,"-property","FontSize");'>> temp.m 
           echo 'set(FS,"FontSize",8);'>> temp.m 
           echo 'W = 4; H = 3;'>> temp.m 
           echo 'set(h,"PaperUnits","inches")'>> temp.m 
           echo 'set(h,"PaperOrientation","portrait");'>> temp.m 
           echo 'set(h,"PaperSize",[H,W])'>> temp.m 
           echo 'set(h,"PaperPosition",[0,0,W,H])'>> temp.m 
           echo 'xlim([A(1,1) A(imax,1) ]); '>> temp.m 
           echo 'xlabel("# Snap","Fontsize",12)'>> temp.m 
           echo "ylabel(\" "${DUMMY_NAME}" \",\"Fontsize\",12)">> temp.m 
           echo "title(\" "${DUMMY_TITLE}" \",\"Fontsize\",10)">> temp.m 
           echo "print(h,\"" ${DUMMY_DAT}".png\",\"-dpng\",\"-color\")">> temp.m 
           echo 'exit'>> temp.m 
#    
           $OCTAVE  --no-gui -W -q  temp.m  > mlog 
           rm -f mlog 
        fi
#
        FMT="${FMT} %13.3f "
     done

     if [ "$DO_STAT_PLOT" -eq "1" ]
     then 
#       Pasting plots
        J="0"
        for ((I=2; I <= NF; I+=4 ))
        do 
          let " J = $J + 1 "
          let " I0 = $I "
          let " I1 = $I + 1 "
          let " I2 = $I + 2"
          let " I3 = $I + 3 "
          PNGFILES=""
          if [ -e ${prefix}_${I0}.png ]; then PNGFILES="${prefix}_${I0}.png"; fi
          if [ -e ${prefix}_${I1}.png ]; then PNGFILES="$PNGFILES ${prefix}_${I1}.png"; fi
          if [ -e ${prefix}_${I2}.png ]; then PNGFILES="$PNGFILES ${prefix}_${I2}.png"; fi
          if [ -e ${prefix}_${I3}.png ]; then PNGFILES="$PNGFILES ${prefix}_${I3}.png"; fi
          $CONVERT ${PNGFILES} +append ${prefix}_${J}_TEMP.png  
        done
        $CONVERT ${prefix}_*_TEMP.png -append ${prefix}.png
        rm -f ${prefix}_*.png
     fi
#
     if [ "$DO_STAT_PERCEN" -gt "0" ]
     then 
        HEADING=" $(head -1 $file) USING TOP ${DO_STAT_PERCEN}% RESULTING IN NDAT= $NR_filt" 
     elif [ "$DO_STAT_PERCEN" -lt "0" ]
     then
        HEADING=" $(head -1 $file) USING BOTTOM ${DO_STAT_PERCEN}% RESULTING IN NDAT= $NR_filt" 
     else
        HEADING=" $(head -1 $file) USING ALL DATA NDAT= $NR_filt" 
     fi
     echo $HEADING >  ${prefix}.med 
     printf " Mean  ${FMT} \n" ${MEAN[*]}  >> ${prefix}.med
     printf " Max   ${FMT} \n" ${MAX[*]}  >> ${prefix}.med
     printf " Min   ${FMT} \n" ${MIN[*]}  >> ${prefix}.med
     printf " SE    ${FMT} \n" ${SE[*]}  >> ${prefix}.med
     printf " BE    ${FMT} \n" ${BSE[*]}  >> ${prefix}.med
     printf " LBE   ${FMT} \n" ${LBE[*]}  >> ${prefix}.med
     echo '# SE: standard error ' >> ${prefix}.med
     echo '# BE: block error estimate (non-linear fitting)'  >> ${prefix}.med
     echo '#LBE: limiting block error estimate '  >> ${prefix}.med
     if [ !  "$NR" -eq "$NR_filt" ]  
     then 
        echo "Filtered data written out in ${prefix}.dat_filt   $NR $NR_filt "
        echo $HEADING >  ${prefix}.dat_filt
        cat  temp.dat_filtered  >>  ${prefix}.dat_filt
     fi
     unset MEAN MAX MIN SE BSE LBE FMT HEADING
     echo 
   fi
done
rm -f temp.*  TEMP.BSE
     


